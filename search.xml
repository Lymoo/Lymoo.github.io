<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[了解React基础]]></title>
      <url>%2F2017%2F04%2F10%2F%E4%BA%86%E8%A7%A3React%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[什么是ReactReact是一个用于构建用户界面的JavaScript库，而不是一个MVC框架，但可以使用React作为MVC架构的View层轻易的在已有项目中使用。React起源于Facebook的内部项目，用来架设Instagram的网站，并于2013年5月开源。React拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 React的特点虚拟DOM结构以前没有ajax技术的时候，web页面从服务端整体渲染出html输出到浏览器端进行渲染，同样的，用户的一个改变页面的操作也会刷新整个页面来完成。直到有了ajax出现，实现页面局部刷新，带来的高效和分离让web开发者们惊叹不已。但随之而来的问题是，复杂的用户交互及展现需要通过大量的DOM操作来完成，这让页面的性能以及开发的效率又出现了新的瓶颈。时至今日，谈到前端性能优化，减少DOM元素、减少reflow和repaint、编码过程中尽量减少DOM的查询等手段是大家耳熟能详的。而页面任何UI的变化都是通过整体刷新来完成的。幸运的是，React通过自己实现的DOM Diff算法，计算出虚拟页面当前版本和新版本之间的差异，最小化重绘，避免不必要的DOM操作，解决了这两个公认的前端性能瓶颈，实现高效DOM渲染。我们知道，频繁的操作DOM所带来的性能消耗是很大的，而React之所以快，是因为它不直接操作DOM，而是引进虚拟DOM的实现来解决这个问题对于页面的更新，React通过自己实现的DOM Diff算法来进行差异对比、差异更新，反映到页面上就是只重绘了更新的部分，从而提高渲染效率。 组件化在业务开发中，遇到公共的模板部分，我们不得不将模板和规定的数据格式耦合在一起来实现组件。而在React中，我们可以使用JSX语法来封装组件，将组件的结构、数据逻辑甚至样式都聚合在一起，更加简单、明了、直观的定义组件。有了组件化的实现，我们可以很直观的将一个复杂的页面分割成若干个独立组件，再将这些独立组件组合完成一个复杂的页面。这样既减少了逻辑复杂度，又实现了代码的重用。 配置React的开发环境获取相关文件首先我们需要获取到React的开发文件，可以从React官网下载相关配置文件，由于React用到的是JSX语法，浏览器是不能够直接进行解析的，还需要配置一个将JSX转换成JavaScript的文件，将链接中的代码复制到自己本地的任意新建的一个文件中保存完成配置，最后配置文件如下图所示： 配置React开发文件模板新建一个HTML文件进行如下配置，当这个文件配置好之后，以后需要开发React的程序都可以以这个为模板进行开发。12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入react核心库--&gt; &lt;script type="text/javascript" src="build/react.js"&gt;&lt;/script&gt; &lt;!--引入react的DOM操作--&gt; &lt;script type="text/javascript" src="build/react-dom.js"&gt;&lt;/script&gt; &lt;!--把JSX语法转换成浏览器能识别的JavaScript--&gt; &lt;script type="text/javascript" src="build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--把通过react生成的DOM放置在#container里面--&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;!--写JSX的地方需要设置为text/babel--&gt; &lt;script type="text/babel"&gt; // 在这里写react代码 &lt;/script&gt;&lt;/html&gt; JSX的认识上文提到的JSX是什么东西呢？其实JSX是一种语法，不是一门新的语言，它既包括JavaScript和Xhtml语言，XHTML用标签来进行表示，JavaScript用{}展示。这里主要注意的是写JSX的地方需要设置为text/babel，以及内部的书写规范 简单的React示例这里举一个例子展示一个最简单的React程序因为React放置的是虚拟的DOM结构，我们需要将它渲染至页面上，它提供的语法为ReactDOM.render()它里面可以有三个参数，第一个为我们想要渲染至页面上的DOM元素，第二个为我们想在页面的哪个节点元素中进行渲染，第三个为渲染成功以后的回调12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="build/react.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="build/react-dom.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type="text/babel"&gt; var name = "zhangsan"; ReactDOM.render( &lt;h1&gt;hello &#123;name&#125;&lt;/h1&gt;, document.getElementById("container") ); // 这里有第二种写法 ReactDOM.render( React.createElement("h1", null, "hello " + name), document.getElementById("container") ) &lt;/script&gt;&lt;/html&gt; 展示的效果为如果想要渲染出多个相同标签的不同内容，React也提供了一种方式，用key来确定标签的不同，以下展示部分script代码1234567891011var names = ["Alice", "Cindy", "Rose"];ReactDOM.render( &lt;ul&gt; &#123; names.map(function (name, key) &#123; return &lt;li key=&#123;key&#125;&gt;&#123;name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;, document.getElementById("container")) 展示的效果为 React组件在react中将一些重用的dom结构进行了封装，就称为组件，它便于我们进行代码管理以及代码复用 组件的命名规则首字母必须大写，使用驼峰命名法 组件的构建方法React提供了一个命令为React.createClass()来创建一个组件，它内部包含一个必须要有的方法render，用来返回一个或多个的DOM结构 封装一个简单的组件示例12345var HelloMessage = React.createClass(&#123; render: function () &#123; return &lt;h1&gt;hello message&lt;/h1&gt; &#125;&#125;); 这样就简单的封装了一个名为HelloMessage的组件，如果想要调用这个组件，方法为1234ReactDOM.render( &lt;HelloMessage/&gt;, document.getElementById("container")) 复合组件复合组件简单来说即是组件套用组件，我们来尝试封装一个复合组件1234567891011121314151617181920var Component1 = React.createClass(&#123; render: function () &#123; return &lt;h1&gt;测试&lt;/h1&gt; &#125;&#125;);var Component2 = React.createClass(&#123; render: function () &#123; return &lt;a href="http://www.baidu.com" target="_blank"&gt;去百度&lt;/a&gt; &#125;&#125;);var Component3 = React.createClass(&#123; render: function () &#123; return ( &lt;div&gt; &lt;Component1/&gt; &lt;Component2/&gt; &lt;/div&gt; ) &#125;&#125;); React的CSS样式React有三种添加样式的方法 1.内联样式123456789var StyleTest = React.createClass(&#123; render: function () &#123; return &lt;div style=&#123;&#123;backgroundColor: "red", border: "10px solid #ccc"&#125;&#125;&gt;Test&lt;/div&gt; &#125;&#125;);ReactDOM.render( &lt;StyleTest/&gt;, document.getElementById("container")) 效果展示： 2.对象样式注意这里的styles都是以对象的格式进行书写的，千万不要以前的习惯后面写封号，字段名不加引号等等12345678910111213var styles = &#123; color: "blue", backgroundColor: "green"&#125;;var StyleTest = React.createClass(&#123; render: function () &#123; return &lt;div style=&#123;styles&#125;&gt;Test&lt;/div&gt; &#125;&#125;);ReactDOM.render( &lt;StyleTest/&gt;, document.getElementById("container")) 效果展示： 3.选择器样式这个就和我们原来的CSS书写差不多，但是类名的添加不再是class，注意这里是className123456789101112131415&lt;style&gt; .styles&#123; color: yellow; background-color: black; &#125;&lt;/style&gt;var StyleTest = React.createClass(&#123; render: function () &#123; return &lt;div className="styles"&gt;Test&lt;/div&gt; &#125;&#125;);ReactDOM.render( &lt;StyleTest/&gt;, document.getElementById("container")) 效果展示： React的属性propsprops简单来说就是一个组件的私有属性，从父组件传递一些需要的值到子组件中来使用使用方法为this.props，这里的this便代表它的父组件，props则代表了父组件上的所有元素，是一个数组用法示例:123456789var PropsTest = React.createClass(&#123; render: function () &#123; return &lt;h1&gt;hello &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;);ReactDOM.render( &lt;PropsTest name="zhangsan"/&gt;, // 这里的name值会传递到h1的标签中相应的位置 document.getElementById("container")) 这里有一个特例为this.props.children，它表示的是组件的所有子节点1234567891011121314151617181920var PropsTest = React.createClass(&#123; render: function () &#123; return &#123; &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child)) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt; &#125; &#125; &lt;/ol&gt; &#125; &#125;&#125;)ReactDOM.render(&#123; &lt;PropsTest&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/PropsTest&gt;, document.getElementById("conotainer")&#125;) 效果展示： 设置默认值React提供一个专门设置props的默认值命令getDefaultProps具体用法为：123456789101112131415var PropsTest = React.createClass(&#123; getDefaultProps: function () &#123; // 设置该组件属性的初始值 return &#123; name: "lisi" &#125; &#125;, render: function () &#123; return &lt;h1&gt;hello &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;);ReactDOM.render( &lt;PropsTest/&gt;, document.getElementById("container")); 效果展示： 设置props数据类型123456789101112131415161718var PropsTest = React.createClass(&#123; propTypes: &#123; // 设置数据的类型 name: React.PropTypes.string.isRequired &#125;, getDefaultProps: function () &#123; return &#123; name: "lisi" &#125; &#125;, render: function () &#123; return &lt;h1&gt;hello &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;);ReactDOM.render( &lt;PropsTest/&gt;, document.getElementById("container")); React的状态stateReact把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染UI，让用户界面和数据保持一致。React里，只需更新组件的state，然后根据新的state重新渲染用户界面（不要操作DOM）。getInitialState方法用于定义初始状态，也就是一个对象，这个对象可以通过this.state属性读取。当用户点击组件，导致状态变化，this.setState方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件。1234567891011121314151617181920var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? '喜欢' : '不喜欢'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; 你&lt;b&gt;&#123;text&#125;&lt;/b&gt;我。点击切换状态。 &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById("container")); React组件生命周期React的生命周期可以分为三个状态：1.Mounting：已插入真实DOM2.Updating：正在被重新渲染3.Unmounting：已移出真实DOM 生命周期的方法componentWillMount:在渲染前调用,在客户端也在服务端。componentDidMount:在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。componentWillReceiveProps:在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。shouldComponentUpdate:返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。componentWillUpdate:在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。componentDidUpdate:在组件完成更新后立即调用。在初始化时不会被调用。componentWillUnmount:在组件从DOM中移除的时候立刻被调用。以下示例在Hello组件加载以后，通过componentDidMount方法设置一个定时器，每隔100毫秒重新设置组件的透明度，并重新渲染123456789101112131415161718192021222324252627282930var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;Hello name="world"/&gt;, document.getElementById('example'));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些前端面试题的整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[个人整理的一些最近碰到的一些较为有用的前端题目 标签属性中title和alt的区别答:title是设置鼠标移动到图片上时显示的内容，而alt是用于当图片没有正常显示时出现的提示文字，另外alt还用于在seo中针对图片的优化说明. 隐藏元素的几种方法答: 1.display:none;2.visibility:hidden;3.opacity:0;4.position:absolute;left:-10000px; JavaScript中有哪几种数据类型答:JavaScript中有5种简单数据类型（也称为基本数据类型）:Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的 回答以下输出的类型答:alert(typeof(null));//objectalert(typeof(NaN));//numberalert(typeof(undefined));//undefinedalert(typeof(“undefined”));//stringalert(NaN == undefined);//falsealert(NaN == NaN);//false 用jquery和原生js获取元素中的内容答:JS:document.getElementById(“div1”).innerHTML;document.querySelector(“#div1”).innerText;JQ:$(“#div1”).html() 用原生js封装一个添加监听事件的兼容写法答:123456789function addEvent(obj,event,fn)&#123; //现代：addEventLister 不用加on //ie：touchEvent 需要加on if (window.addEventListener)&#123; obj.addEventListener(event,fn); &#125;else&#123; obj.attachEvent("on"+event, fn); &#125;&#125; 对跨域的理解和解决办法答:跨域简单的理解即为当前服务器目录下的前端需求要请求非本服务器(本域名)下的后台服务就称为跨域请求。跨域请求我们使用普通的ajax请求是无法进行的同源策略，一般来说位于 server1.example.com 的网页无法与不是 server2.example.com的服务器沟通，或者说如果在server1.example.com下想获取server2.example.com的话就得用跨域请求。跨域的解决方法及解决：通过script标签请求，或者通过jQuery跨域 Ajax的原理答:Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 jQuery库中的$()是什么答:$()函数用于将任何对象包裹成jQuery对象，接着你就被允许调用定义在 jQuery对象上的多个不同方法。你甚至可以将一个选择器字符串传入$()函数，它会返回一个包含所有匹配的DOM元素数组的jQuery对象。 JavaScript的window.onload事件和jQuery的ready函数有何不同答:JavaScript的window.onload事件和jQuery的ready函数之间的主要区别是，前者除了要等待DOM被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在window.onload 事件上的代码在执行时有明显的延迟。另一方面，jQuery的ready()函数只需对DOM树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用jQuery $(document).ready()的另一个优势是你可以在网页里多次使用它，浏览器会按它们在HTML页面里出现的顺序执行它们，相反对于onload技术而言，只能在单一函数里使用。鉴于这个好处，用jQuery的ready()函数比用JavaScript的window.onload 事件要更好些。 用原生js封装一个能获取元素到页面最上方和最左侧的函数，再用JQ封装一个同样的函数答:原生:12345678910function offset(obj)&#123; var l = 0; var t = 0; while(obj)&#123; l+=obj.offsetLeft; t+=obj.offsetTop; obj = obj.offsetParent; &#125; return &#123;left:l,top:t&#125;;&#125; jQuery：$().offset().left;$().offset().top 如何实现一个EventEmitter答:主要分三步：定义一个子类，调用构造函数，继承EventEmitter1234567891011var util = require('util');var EventEmitter = require('events');function MyEmitter() &#123; EventEmitter.call(this);&#125; // 构造函数util.inherits(MyEmitter, EventEmitter); // 继承var em = new MyEmitter();em.on('hello', function(data) &#123; console.log('收到事件hello的数据:', data);&#125;); // 接收事件，并打印到控制台em.emit('hello', 'EventEmitter传递消息真方便!'); 如何通过stream实现一个文件的复制答:1234var fs = require("fs");var rs = fs.createReadStream(“1.jpg");var ws = fs.createWriteStream("2.jpg");rs.pipe(ws); 如何理解node的同步和异步答:”同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 使用node构建一个服务器并对向”/post”发起的post请求进行处理，要求拿到post请求传输的数据（不包括文件上传）答:12345678910111213141516var http = require("http");var queryString = require("querystring");var server = http.createServer(function (req,res) &#123; if(urlObj.pathname == "/post")&#123; var str = ""; req.on("data",function (chunk) &#123; str+=chunk; &#125;); req.on("end",function () &#123; var query = queryString.parse(str); console.log(query); &#125;) res.end("你请求的地址是"+urlObj.pathname); &#125;&#125;);server.listen(8080); 用node模拟客户端发起请求答:12345678910111213var http = require("http");var request = http.request(&#123; host:"localhost", port:"8080", path:"/request", method:"post"&#125;,function (res) &#123; res.on("data",function (chunk) &#123; console.log(chunk.toString()); &#125;);&#125;);request.write("user=zhang&amp;pass=111");request.end("请求结束");//结束本次请求 图片预加载的意义和原理答:预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览网站内容时获得更好的用户体验。实例代码：1234567891011121314151617181920212223//obj.imgArr 图片数组//obj.loadingProgress 加载进度//obj.loadingOver 加载结果(function ()&#123; var imgObjs = []; loadingFn = function (obj) &#123; var index = 0; for (var i = 0; i &lt; obj.imgArr.length; i++) &#123; var imgObj = new Image(); imgObj.onload = function() &#123; index++; imgObjs.push(this); if (obj.loadingProgress)&#123; obj.loadingProgress(index, this); &#125; if (index &gt; obj.imgArr.length-1)&#123; obj.loadingOver(imgObjs); &#125; &#125; imgObj.src = obj.imgArr[i]; &#125; console.log(obj); &#125; 浏览器页面有哪三层构成，分别是什么，作用是什么?答:浏览器页面构成：结构层、表示层、行为层分别是：HTML、CSS、JavaScript作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 什么是语义化的HTML?答:直观的认识标签，对于搜索引擎的抓取有好处，用正确的标签做正确的事情！html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析，在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 CSS居中（包括水平居中和垂直居中）答:水平居中设置:1.行内元素设置 text-align:center；2.Flex布局设置display:flex;justify-content:center;(灵活运用,支持Chroime，Firefox，IE9+) 垂直居中设置：1.父元素高度确定的单行文本（内联元素）设置 height = line-height；2.父元素高度确定的多行文本（内联元素）a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle；b:先设置 display:table-cell 再设置 vertical-align:middle；块级元素居中方案 水平居中设置：1.定宽块状元素设置 左右 margin 值为 auto；2.不定宽块状元素a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto；b:给该元素设置 displa:inine 方法；c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%； 垂直居中设置：使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了;利用display:table-cell属性使内容垂直居中;使用css3的新属性transform:translate(x,y)属性;使用:before元素; CSS3有哪些新特性？答:CSS3实现圆角（border-radius: 8px），阴影（box-shadow: 10px），对文字加特效（text-shadow），线性渐变（gradient），变换（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜还增加了更多的CSS选择器，多背景，rgba等 事件委托是什么？答:利用事件冒泡的原理，使自己的所触发的事件，让它的父元素代替执行！ 什么叫优雅降级和渐进增强？答:优雅降级:Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 JavaScript原型，原型链都是什么? 有什么特点？答:原型对象也是普通的对象，是对象一个自带隐式的 proto属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 如何阻止事件冒泡和默认事件答:阻止冒泡:现代浏览器:e.stopPropagation低版本浏览器:e.cancelBubble=true 阻止默认事件:现代浏览器:e.preventDefult()低版本浏览器:return false iOS苹果和微信中音频和视频实现自动播放的方法答:1234567//一般情况下，这样就可以自动播放了，但是一些奇葩iPhone机不可以 document.getElementById('audio').play(); //必须在微信Weixin JSAPI的WeixinJSBridgeReady才能生效 document.addEventListener("WeixinJSBridgeReady", function () &#123; document.getElementById('audio').play(); document.getElementById('video').play(); &#125;, false); 解释GET/POST的区别答:GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。关于传输数据的大小在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。关于安全性Get是Form的默认方法，安全性相对比较低 描述一下cookies，sessionStorage和localStorage的区别答:sessionStorage和localStorage是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中 sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage对象也是不同的。cookies会发送到服务器端。其余两个不会。Microsoft指出Internet Explorer 8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。Firefox每个域名cookie限制为50个。Opera每个域名cookie限制为30个。Firefox和Safari允许cookie多达4097个字节，包括名name）、值（value）和等号。Opera许cookie多达4096个字节，包括：名（name）、值（value）和等号。Internet Explorer允许cookie多达4095 个字节，包括：名（name）、值（value）和等号。区别：Cookie:每个域名存储量比较小（各浏览器不同，大致 4K ）所有域名的存储量有限制（各浏览器不同，大致 4K ）有个数限制（各浏览器不同）会随请求发送到服务器LocalStorage:永久存储单个域名存储量比较大（推荐 5MB ，各浏览器不同）总体数量无限制SessionStorage:只在Session内有效存储量更大（推荐没有限制，但是实际上各浏览器也不同） image和canvas在处理图片的时候有什么区别？答:image是通过对象的形式描述图片的。canvas通过专门的API将图片绘制在画布上。 响应式布局的时候，轮播图使用两张不同的图片去适配大屏幕和超小屏幕，还是一张图片进行压缩适配不同终端，说明原因？答:最好使用两张不同大小的图片去适配大屏幕和超小屏幕，这样可以针对不同设备的屏幕大小，来加载响应的图片，减少超小屏幕设备的网络流量消耗，加快响应速度，同时防止图片在大屏幕下分辨率不够导致失真的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈AngularJS]]></title>
      <url>%2F2017%2F04%2F08%2F%E6%B5%85%E8%B0%88AngularJS%2F</url>
      <content type="text"><![CDATA[博主最近了解学习了一下angularJS，记录一下心得给大家分享一下~ 什么是AngularJSAngularJS是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在WEB应用程序中使用HTML声明动态内容。 AngularJS有5个主要核心特性双向数据绑定实现了把model与view完全绑定在一起，model变化，view也变化，反之亦然。 模板在AngularJS中，模板相当于HTML文件被浏览器解析到DOM中，AngularJS遍历这些DOM，也就是说AngularJS把模板当做DOM来操作，去生成一些指令来完成对view的数据绑定。 MVVM吸收了传统的MVC设计模式但又不是传统意义上的MVC，更接近于MVVM(Moodel-View-ViewModel)。 依赖注入AngularJS拥有内建的依赖注入子系统，可以帮助开发人员更容易的开发，理解和测试应用。 指令可以用来创建自定义的标签，也可以用来装饰元素或者操作DOM属性。 AngularJS的特点前后端分离，后端只需提供数据接口，路由，模板渲染等都在前端完成html和js分离，展示和逻辑分离减少JS代码，减少DOM元素查找，事件绑定等代码适合API开发 AngularJS的一些简单使用方式首先在页面引入angular.js文件！AngularJS有一套完整的、可扩展的、用来帮助web应用开发的指令集，它使得HTML可以转变成“特定领域语言(DSL)”，是用来扩展浏览器能力的技术之一，在DOM编译期间，和HTML关联着的指令会被检测到，并且被执行，这使得指令可以为DOM指定行为，或者改变它。AngularJS通过称为指令的新属性来扩展的HTML，带有前缀ng-，我们也可以称之为“指令属性”，它就是绑定在DOM元素上的函数，可以调用方法、定义行为、绑定controller及$scope对象、操作DOM，等等。AngularJS指令指示的是“当关联的HTML结构进入编译阶段时应该执行的操作”，它本质上只是一个当编译器编译到相关DOM时需要执行的函数，可以写在元素的名称里，属性里，css类名里，注释里。当浏览器启动、开始解析HTML时，DOM元素上的指令属性就会跟其他属性一样被解析，也就是说当一个Angular.js应用启动，AngularJS编译器就会遍历DOM树来解析HTML，寻找这些指令属性函数，在一个DOM元素上找到一个或多个这样的指令属性函数，它们就会被收集起来、排序，然后按照优先级顺序被执行。Angular.js应用的动态性和响应能力，都要归功于指令属性，常见的有：ng-app、ng-init、ng-model、ng-bind、ng-repeat等等。 ng-appng-app指令来标明一个AngularJS应用程序，并通过AngularJS完成自动初始化应用和标记应用根作用域，同时载入和指令内容相关的模块，并通过拥有ng-app指令的标签为根节点开始编译其中的DOM。引用方法很简单，如下所示：12&lt;div ng-app&gt;&lt;/div&gt; 如上引用，一个AngularJS应用程序初始化就完成了并标记了作用域，也就是div元素就是AngularJS应用程序的”所有者”，在它里面的指令也就会被AngularJS编译器所编译、解析了。 ng-initng-init指令初始化应用程序数据，也就是为AngularJS应用程序定义初始值，通常情况下，我们会使用一个控制器或模块来代替它，后面我们会介绍有关控制器和模块的知识。如下所示，我们为应用程序变量name赋定初始值。12&lt;div ng-app=“” ng-init=“name=‘zhangsan’”&gt;&lt;/div&gt; 我们不仅可以赋值字符串，也可以赋值为数字、数组、对象，而且可以为多个变量赋初始值，如下所示：12&lt;div ng-app=“” ng-init=“width=3;length=5”&gt;&lt;/div&gt; ng-model在AngularJS中，只需要使用ng-model指令就可以把应用程序数据绑定到HTML元素，实现model和view的双向绑定。如下示例，使用ng-model指令对数据进行绑定。1234&lt;div ng-app=“”&gt;请输入任意值：&lt;input type=“text” ng-model=“name”&gt;你输入的为： &#123;&#123; name &#125;&#125;&lt;/div&gt; ng-model把相关处理事件绑定到指定标签上，这样我们就可以不用在手工处理相关事件(比如change等)的条件下完成对数据的展现需求。以上介绍了ng-model的单向绑定(view-&gt;model)后面控制器我们会用到它的双向绑定功能。 ng-model原理angularJS加载完成之后会启动，首先找 ng-app指令找到后认为ng-app里面的所有的内容都归angularJS来管找子层标签里所有的指令，然后就可以找到ng-model找到后会生成数据模型，然后挂在根作用域上面。然后下面所有的标签都可以读取ng-model的值。 ng-bind指令ng-bind和AngularJS表达式有异曲同工之妙，但不同之处就在于ng-bind是在angularJS解析渲染完毕后才将数据显示出来的。如下使用ng-bind指令绑定把应用程序数据。1234&lt;div ng-app=“”&gt; 请输入一个名字：&lt;input type=“text” ng-model=“name”&gt; Hello &lt;span ng-bind=“name”&gt;&lt;/span&gt;&lt;/div&gt; PS：使用花括号语法时，因为浏览器需要首先加载页面，渲染它，然后AngularJS才能把它解析成你期望看到的内容，所以对于首个页面中的数据绑定操作，建议采用ng-bind，以避免其未被渲染的模板被用户看到。 ng-clickAngularJS也有自己的HTML事件指令，比如说通过ng-click定义一个AngularJS单击事件。对按钮、链接等，我们都可以用ng-click指令属性来实现绑定，如下简单示例：1234567&lt;div ng-app=“” ng-init=“click=false”&gt; &lt;button ng-click=“click= !click”&gt;隐藏/显示&lt;/button&gt; &lt;div ng-hide=“click”&gt; 请输入一个名字：&lt;input type=“text” ng-model=“name”&gt; Hello &lt;span ng-bind=“name”&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; PS：ng-hide=“true”，设置HTML元素不可见。ng-click指令将DOM元素的鼠标点击事件(即mousedown)绑定到一个方法上，当浏览器在该DOM元素上鼠标触发点击事件时，AngularJS就会调用相应的方法。 ng-repeatng-repeat指令，遍历一个数据集合中的每个数据元素，并且加载HTML模版把数据渲染出来，当我们要向HTML容器节点中添加更多类似DOM元素的时候，使用ng-repeat是再好不过了。ng-repeat指令对于集合中(数组中)的每一项都会渲染一次HTML元素。例1:12345&lt;body ng-app=“” ng-init=“arr=[‘3’,’5’,’9’]”&gt; &lt;ul&gt; &lt;li ng-repeat=“x in arr”&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 例2:12345678&lt;body ng-app=“” ng-init=“obj=&#123;‘user’:’zhangsan’,’pass’:’12345’,’sex’:’man’&#125;”&gt; &lt;table border=“1”&gt; &lt;tr ng-repeat=“(key,value) in obj”&gt; &lt;td&gt;&#123;&#123;key&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;value&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; ng-classng-class是AngularJS预设的一个指令，用于动态自定义dom元素的css class name1234567891011121314151617181920&lt;head&gt; &lt;meta charset=“utf-8”&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=“text/css”&gt; .active&#123; color: red; &#125; .inactive&#123; color: green; &#125; &lt;/style&gt; &lt;script src=“angular.min.js” type=“text/javascript” charset=“utf-8”&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=“” ng-init=“isActive=false”&gt; &lt;input type=“text” ng-model=“name1” /&gt; &lt;input type=“text” ng-model=“name2” /&gt; &lt;div ng-class=“&#123;true:’active’,false:’inactive’&#125;[isActive]”&gt; &#123;&#123;name1 +” “+ name2&#125;&#125; &lt;/div&gt;&lt;/body&gt; ng-includeng-include就是将多个页面的公共页面提取出来，如header.html，footer.html等，在每个页面用1&lt;div ng-include=“’header.html’”&gt;&lt;/div&gt; 来引入。注意: 必须用web容器打开站点才能成功，用本地文件的模式访问会报错ng-include的值是如果要写为文件名的话需要加单引号，否则会被当作一个变量来处理。 自定义指令控制器scopeAngularJS控制器控制AngularJS应用程序的数据，是常规的JavaScript对象。ng-controller指令就是用来定义应用程序控制器的，并且同时创建了一个新的作用域关联到相应的DOM元素上。所谓作用域就是一个指向应用模型的对象，它是表达式的执行环境，作用域有层次结构，这个层次和相应的DOM几乎是一样的，作用域能监控表达式和传递事件并且可以从父作用域继承属性。每一个AngularJS应用都有一个绝对的根作用域。但也可能有多个子作用域。 一个应用可以有多个作用域，因为有一些指令会生成新的子作用域，当新作用域被创建的时候，他们会被当成子作用域添加到父作用域下，这使得作用域会变成一个和相应DOM结构一个的树状结构。 控制器上的属性现在我们就用ng-controller指令来创建一个简单的控制器定义，如下所示：1234567891011&lt;div ng-app=“” ng-controller=“MyController”&gt;请输入一个名字：&lt;input type=“text” ng-model=“person.name”&gt; Hello &lt;span ng-bind=“person.name”&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt;function MyController ($scope) &#123; $scope.person = &#123; name: “zhangsan” &#125;;&#125;&lt;/script&gt; 如上所述，我们通过ng-controller指令创建了一个JavaScript对象 —— MyController并带有name属性，那参数$scope是什么呢，代表什么意思呢。现在我们就来解答MyController对象参数 —— $scope。$scope就是把一个DOM元素连结到控制器上的对象，它提供一个绑定到DOM元素(以及其子元素)上的执行上下文。它也是一个JavaScript对象，指向应用程序作用域内的所有HTML元素和执行上下文。要明确创建一个$scope对象，我们就要给DOM元素安上一个controller对象，使用的是ng-controller 指令属性。所有$scope都遵循原型继承，这意味着它们都能访问父$scope们,对任何属性和方法，如果AngularJS在当前$scope上找不到，就会到父$scope上去找，如果在父$scope上也没找到，就会继续向上回溯，一直到$rootScope上，这个$rootScope是最顶级的$scope，它对应着含有 ng-app指令属性的那个DOM元素，也就是说根作用域关联的DOM就是ng-app指令定义的地方。也就是说，拥有了$scope，我们就可以操作作用域内任何我们想要获取的对象数据。 控制器上的方法控制器不仅声明属性也可以声明方法，如下所示：123456789101112131415&lt;div ng-app=“” ng-controller=“MyController”&gt; 名称: &lt;input type=“text” ng-model=“username”&gt; &lt;button ng-click=“sayHello()”&gt;打招呼&lt;/button&gt; &lt;hr&gt; &#123;&#123;greeting&#125;&#125;&lt;/div&gt;&lt;script&gt;function MyController($scope) &#123; $scope.username = ‘zhangsan’; $scope.sayHello = function() &#123; $scope.greeting= ‘Hello ‘ + $scope.username + ‘!’; &#125;;&#125;&lt;/script&gt; 注意事项不要试图去复用controller,一个控制器一般只负责一小块视图不要在controller中操作DOM，这不是控制器的职责，是指令的职责。不要在controller里做数据格式化，ng有很好用的过滤器实现此功能。不要在controller里面做数据过滤操作，ng有$filter服务一般来说，controller是不会互相调用的，控制器这间的交互是通过事件进行的。 创建指令指令定义对象的常用属性如下：template : string使用template指定的HTML标记替换指令内容（或指令自身）restrict : string用来限定指令在HTML模板中出现的位置。replace : true|false使用这个属性指明template的替换方式。12345678&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller="testController"&gt; &lt;text-directive&gt;&lt;/text-directive&gt;&lt;/body&gt; AngularJS的服务AngularJS提供了一些功能的封装，但是当你试图通过全局对象angularJS去 访问这些功能时，却发现与以往遇到的库大不相同。$http比如，在jQuery中，我们知道它的API通过一个全局对象：$ 暴露出来，当你需要 进行ajax调用时，使用$.ajax()就可以了。这样的API很符合思维的预期。AngularJS也暴露了一个全局对象：angularJS，也对ajax调用进行封装提供了一个 $http对象，但是，但是，当你试图沿用旧经验访问angular.$http时，发现不是 那么回事！在angularJS中是以一个参数的形式传递到控制器中，如果要使用它，需要在 controller 中定义。 $http服务12345678910111213141516171819&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="angular.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://apps.bdimg.com/libs/angular.js/1.5.0-beta.0/angular-sanitize.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt; &lt;div ng-controller="myCtrl"&gt; &lt;span ng-bind-html="content"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var app = angular.module("myApp", ['ngSanitize']); app.controller("myCtrl", function ($scope, $http) &#123; $http.get("content.html").success(function (res) &#123; $scope.content = res; &#125;) &#125;);&lt;/script&gt; 定时器1234567var app = angular.module(“myApp”,[]);app.controller(“myCtrl”,function ($scope,$timeout)&#123; $timeout(function ()&#123; alert(‘a’); &#125;,2000);&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041var app = angular.module(“myApp”,[]);app.controller(“myCtrl”,function ($scope,$interval)&#123; //循环定时器 $interval(function ()&#123; alert(‘a’); &#125;,2000);&#125;);## 模仿百度搜索功能```html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app="myApp" ng-controller="myController"&gt; &lt;input type="text" ng-model="wd" ng-change="change()"&gt; &lt;ul&gt; &lt;li ng-repeat="item in query"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript" src="angular.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="angular-sanitize.js"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module("myApp", ["ngSanitize"]); function myControllerCb ($scope, $http) &#123; $scope.wd = ""; $scope.change = function () &#123; $http.jsonp("https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd="+$scope.wd+"&amp;cb=JSON_CALLBACK").then(function (res) &#123; console.log(res.data); $scope.query = res.data.s; &#125;); &#125; &#125; app.controller("myController", myControllerCb); &lt;/script&gt;&lt;/html&gt; AngularJS过滤器过滤器可以使用一个管道字符（|）添加到表达式和指令中。currency——格式化数字为货币格式。filter——从数组项中选择一个子集。lowercase——格式化字符串为小写。orderBy——根据某个表达式排列数组。uppercase——格式化字符串为大写。例1(格式化数字为货币格式):12345678910111213141516171819&lt;body ng-app=“myApp”&gt; &lt;div ng-controller=“myCtrl”&gt; &lt;span&gt;相乘&lt;/span&gt; &lt;input type=“text” ng-model=“num1” /&gt; &lt;input type=“text” ng-model=“num2” /&gt;&lt;br /&gt; &lt;!—currency:”￥” 中文—&gt; 结果为：&#123;&#123;myFn() | currency&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var app = angular.module(“myApp”,[]); app.controller(“myCtrl”,function ($scope)&#123; $scope.num1=5; $scope.num2=10; $scope.myFn = function ()&#123; return $scope.num1*$scope.num2; &#125; &#125;);&lt;/script&gt; 例2(字体大小转换):123456&lt;body ng-app=“”&gt; &lt;div&gt; &lt;!—&#123;&#123;‘HelloWorld’ | lowercase&#125;&#125;—&gt; &#123;&#123;‘HelloWorld’ | uppercase&#125;&#125; &lt;/div&gt;&lt;/body&gt; 例3(筛选):123456&lt;body ng-app=“” ng-init=“arr=[‘tangcaiye’,’zhangsan’,’lisi’]”&gt; 搜索：&lt;input type=“text” ng-model=“name” /&gt; &lt;ul&gt; &lt;li ng-repeat=“x in arr | filter:name”&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 例4(筛选加排序):123456789101112131415161718&lt;body ng-app=“myApp”&gt; &lt;div ng-controller=“myCtrl”&gt; &lt;ul&gt; &lt;li ng-repeat=“x in friends |filter:’a’ | orderBy:order:true”&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script type=“text/javascript”&gt; var app = angular.module(“myApp”,[]); app.controller(“myCtrl”,function ($scope)&#123; $scope.friends = [&#123;name:’John’, phone:’555-1212’, age:21&#125;, &#123;name:’Mary’, phone:’555-9876’, age:19&#125;, &#123;name:’Mike’, phone:’555-4321’, age:10&#125;, &#123;name:’Adam’, phone:’555-5678’, age:35&#125;, &#123;name:’Julie’, phone:’555-8765’, age:29&#125;]; $scope.order=“phone”; &#125;);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js基础（三）]]></title>
      <url>%2F2017%2F03%2F17%2Fnode.js%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[http模块深入http协议http: 超文本传输协议，所有路由都是通过它来传输，通过它能够构建一个客户端与服务端连接的管道http模块: 能够构建服务器环境（模拟客户端） 创建服务器类似node.js基础（一）文章中提到的12345678var http = require("http");var url = require("url");var server = http.createServer(function (req, res) &#123; console.log(req.url); // 打印请求的路径 console.log(req.method); // 打印请求的方法 res.end("结束本次请求");&#125;);server.listen(8080); 实例1使用from表单进行简单的前后台交互首先创建三个文件，index.html和form.html以及http.js（名字随意，具体是了解如何实现）。index.html文件内容1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a href="form.html"&gt;跳转到登录注册页&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; form.html文件内容1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=""&gt; 用户名：&lt;input type="text" name="user"&gt;&lt;br/&gt; 密码：&lt;input type="password" name="pass"&gt;&lt;br/&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; http.js文件内容12345678910111213141516171819var http = require("http");var url = require("url");var fs = require("fs");var server = http.createServer(function (req, res) &#123; var urlObj = url.parse(req.url, true); if (urlObj.pathname == "/" || urlObj.pathname == "/index.html") &#123; // 把本项目中的index.html读出来，写进响应res中 var rs = fs.createReadStream("index.html"); rs.pipe(res); &#125; else if (urlObj.pathname == "/form.html") &#123; fs.createReadStream("form.html").pipe(res); console.log(urlObj.query); // 输出用户名和密码 &#125; else &#123; // 如果输出来乱码的同学可以加上下面这句话 res.writeHead(200, &#123;"Content-Type": "text/html;charset=utf-8"&#125;); res.end("结束本次请求"); &#125;&#125;);server.listen(8080); 至此可以试一下打开http.js的模拟服务器，在浏览器输入http://localhost:8080 进行一下相关操作看一下效果吧。最终效果在终端能够如图所示就大功告成了，但是这里只有简单的两个页面交互，如果有许许多多的页面，每个页面都要去else if判断一下是不是太麻烦了，这里有个较为简便的方法，在http.js的文件中将else if改为如下：123else if (urlObj.pathname != "/favicon.ico") &#123; fs.createReadStream("." + urlObj.pathname).pipe(res);&#125; 这样就不用写很多pathname去一一匹配了~是不是很方便呢！这里默认的传输方式是通过GET，那如果是POST该怎么写呢？ 实例2使用from表单的POST传输方式进行简单的前后台交互还是实例1中的三个文件，将form.html文件的form标签里的属性更改为1&lt;form action="/post" method="post"&gt; 然后再将http.js更改为如下123456789101112131415161718192021222324252627var http = require("http");var url = require("url");var fs = require("fs");var queryString = require("querystring");var formidable = require("formidable");var server = http.createServer(function (req, res) &#123; var urlObj = url.parse(req.url, true); if (urlObj.pathname == "/" || urlObj.pathname == "/index.html") &#123; var rs = fs.createReadStream("index.html"); rs.pipe(res); &#125; else if (urlObj.pathname == "/post") &#123; res.writeHead(200, &#123;"Content-Type": "text/html;charset=utf-8"&#125;); // 处理post传进来的数据 var str = ""; req.on("data", function (chunk) &#123; str += chunk; &#125;); req.on("end", function () &#123; var query = queryString.parse(str); console.log(query); &#125;); res.end("你请求的地址是" + urlObj.pathname); &#125; else if (urlObj.pathname != "/favicon.ico") &#123; fs.createReadStream("." + urlObj.pathname).pipe(res); &#125;&#125;);server.listen(8080); 这样最终效果同GET方式一样能够获取到填写的用户名和密码，并且最终页面返回的结果是“你请求的地址是/post” 实例3使用from表单的POST传输方式进行简单的图片上传的操作这里同样是上述的三个文件，在form.html文件中加上上传文件的标签1&lt;input type="file" name="fileup"&gt; 在http.js中也添加一段对post传输文件的操作，代码如下：1234567891011121314else if (urlObj.pathname == "/post") &#123; // 处理上传文件 var form = new formidable.IncomingForm(); form.parse(req, function (err, fields, files) &#123; // fields: 是提交过来的字段 // files: 是提交过来的文件对象，文件会存储在临时路径 var rs = fs.createReadStream(files.fileup.path); // 将文件从临时路径存放到指定目录下 var ws = fs.createWriteStream("./upload/" + files.fileup.name); rs.pipe(ws); &#125;); res.writeHead(200, &#123;"Content-Type": "text/html;charset = utf-8"&#125;); res.end("你请求的地址是" + urlObj.pathname);&#125; 此时可以测试一下上传一张图片看看能否在upload目录下找到同样的图片~ 实例4ajax请求的发送与接收这里就不需要form.html文件了，将index.html加上一段script标签进行ajax请求发送，代码如下：1234567891011&lt;script&gt; window.onload = function () &#123; var time = document.getElementById("time"); var ajax = new XMLHttpRequest(); ajax.open("GET", "/ajax?user=test&amp;pass=123", true); ajax.send(); ajax.onload = function () &#123; time.innerHTML = ajax.responseText; &#125; &#125;&lt;/script&gt; 在http.js文件中的else if后再加上一段代码1234else if (urlObj.pathname == "/ajax") &#123; // 接收了ajax传输的数据 console.log(urlObj.query);&#125; 最终同样在浏览器输入http://localhost:8080 在终端就能收到ajax发送出来的user和pass两个字段了~ 实例5http模拟客户端这里我们再新建一个名为request.js的文件，这里提供get和post两种写法，代码如下：1234567891011121314151617181920212223242526272829var http = require("http");get方式var request = http.request(&#123; host: "localhost", port: "8080", path: "/request?user=test&amp;pass=111", method: "get"&#125;, function (res) &#123; // console.log(res.statusCode); res.on("data", function (chunk) &#123; console.log(chunk.toString()); &#125;);&#125;);request.end("请求结束"); // 结束本次请求// post方式var request = http.request(&#123; host: "localhost", port: "8080", path: "/request",method: "post"&#125;, function (res) &#123; // console.log(res.statusCode); res.on("data", function (chunk) &#123; console.log(chunk.toString()); &#125;);&#125;);request.write("user=test&amp;pass=111");request.end("请求结束"); // 结束本次请求 然后在http.js文件中再添加一段else if代码123456789101112else if (urlObj.pathname == "/request") &#123; // get方式 console.log(urlObj.query); res.statusCode = 200; res.end('&#123;"err": 0, "msg": "请求的内容"&#125;'); // post方式 req.on("data", function (chunk) &#123; console.log(chunk.toString()); &#125;); res.end('&#123;"err": 0, "msg": "请求的内容"&#125;');&#125; 然后我们先开启一下http.js这个模拟服务器，在运行request.js进行模拟请求，我们会发现request.js会返回出{&quot;err&quot;: 0, &quot;msg&quot;: &quot;请求的内容&quot;}，然后服务器会返回出user=xxx&amp;pass=111 请求结束。如果出现这种结果就说明发送成功了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js基础（二）]]></title>
      <url>%2F2017%2F03%2F16%2Fnode.js%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[node.js的回调函数node.js 异步编程的直接体现就是回调，异步编程依托于回调来实现 例1：服务器的回调123456789101112var http = require("http");var server = http.createServer(function (req, res) &#123; res.writeHead(200, &#123;"Content-Type": "text/html; charset=utf-8"&#125;); console.log("服务运行中"); res.end("服务结束");&#125;);// listen(端口, 域名, 成功的回调)server.listen(8080, "localhost", function () &#123; console.log("服务开启成功"); // 这条会在之后先打印&#125;);console.log("我是服务下的"); // 这条会最先打印 例2：读取文件的操作12345678var fs = require("fs");fs.readFile("test.txt", "utf-8", function (err, data) &#123; if (err) &#123; console.error(err); &#125; console.log(data); // 这条会在之后先打印&#125;);console.log("我是读取操作之后的"); // 这条会最先打印 这里也介绍一下同步的写法123var data = fs.readFileSync("test.txt", "utf-8");console.log(data); // 先执行文件内容console.log("我是读取操作之后的"); // 再执行后续内容 node.js的一些常用模块utilutil是一个工具函数包，这个模块保存了利于其他模块的工具，使用最多的有这三种： 1、实现对象的原型继承1234567891011121314151617181920var util = require("util");function Parent(name, age) &#123; this.name = name; this.age = age; this.sayHello = function () &#123; console.log("hello"); &#125;&#125;Parent.prototype.sayName = function () &#123; console.log(this.name);&#125;function Child(name, age) &#123; // 构造函数继承 Parent.apply(this, arguments);&#125;util.inherits(Child, Parent); // 对象的原型继承var dad = new Parent("老爸", 48);var son = new Child("儿子", 28);son.sayHello();son.sayName(); 2、把一个对象作为字符串输出123// 接着上面的案例var str = util.inspect(son); // 将对象转化成字符串console.log(typeof str); // 输出string 3、数据类型的检测12var util = require("util");console.log(util.isArray([])); // 判断其是否为数组，输出true event事件：又称为发布订阅模式或者观察者模式 获取事件模块的方法：12var events = require("events").EventEmitter(); // 旧版写法var events = require("events"); // 新版写法 注册事件1.on2.addListener3.once 移除事件removeListener 设置最大监听数setMaxListeners(Number); 发出事件emit 实例1234567891011121314151617181920212223242526272829var events = require("events"); var util = require("util");// 创建事件的发布者以及事件的观察者function Girl () &#123; // 假设女孩饿了&#125;;function Boy (name, response) &#123; this.name = name; this.response = response;&#125;;util.inherits(Girl, events); // 继承来自于events原型上的方法var goddess = new Girl();var boy1 = new Boy("男生1", function () &#123; console.log("点饿了么");&#125;);var boy2 = new Boy("男生2", function () &#123; console.log("上美团点外卖");&#125;);var boy3 = new Boy("男生3", function () &#123; console.log("带你去吃饭");&#125;);// 绑定事件监听者goddess.on("ele", boy1.response);goddess.addListener("ele", boy3.response); // on和addListener是等价的goddess.once("ele", boy3.response); // once 只绑定一次 goddess.emit("ele"); // emit 表示发出事件 bufferbuffer：缓存的数据格式，缓存区出现的原因：JavaScript本身不存在二进制的传输，只有字符串的，为了保存和处理二进制数据buffer的形式是一个数组，而数组中的每一项是一个以16进制展示的8位字节buffer是一个类，它能实例出一个全局对象buffer的每一位它的取值范围0-255 创建buffer的方法直接创建1234var buff = new Buffer(12); // 参数为number，表示buffer的长度console.log(buff); // 此时里面是随机的，由系统生成// 填充 后两个参数表示从第几位开始第几位结束buff.fill("a", 3, 6); 通过数组创建1var buff = new Buffer([1, 34, 074, 0xa6]); 通过字符串创建1var buff = new Buffer("我是缓存区"); 转成字符串12var buff = new Buffer([0xe4, 0xbb, 0x8a]);console.log(buff4.toString()); // 输出"今" 拼接buffer1234567var buff1 = new Buffer([0xe4, 0xbb, 0x8a, 0xe5]);console.log(buff1.toString()); // 输出乱码var buff2 = new Buffer([0xa4, 0xa9, 0xe5, 0xa4, 0xa9]);console.log(buff2.toString()); // 输出乱码// 把buffer拼接起来解决输出乱码的问题(concat)console.log(Buffer.concat([buff1, buff2]).toString()); // 输出今天天 但是这个方法太过于消耗内存这里有一个更好的方法StringDecoder1234567// 接上面的例子var StringDecoder = require("string_decoder").StringDecoder; // 返回一个类var decode = new StringDecoder();var str = decode.write(buff1);console.log(str); // 输出今var str2 = decode.write(buff2);console.log(str2); // 输出今天天 fs只包括一些文件以及目录的操作，并提供了这些操作的同步和异步的方法 文件操作读取文件123456789101112// 异步操作// readFile(第一个参数为读取的文件名，第二个为配置参数，第三个为回调函数)fs.readFile("test.txt", "utf-8", function (err, data) &#123; if (err) &#123; console.error(err); // 如果有错误便弹出错误 &#125; console.log(data); // 输出文件的内容&#125;);// 同步操作var data2 = fs.readFileSync("test.txt", "utf-8");console.log(data2); // 输出文件的内容 写入文件12345678// writeFile中的参数类似readFile// 其中第三个参数为配置参数：flag表示的是一个读取的模式 不写默认是w为写入，a是追加写入，r为读取fs.writeFile("test.txt", "我是写入进去的内容", &#123;flag: "a"&#125;, function (err) &#123; if (err) &#123; console.error(err); &#125; console.log("写入成功了");&#125;); 追加写入123456fs.appendFile("test.txt", "我是追加进去的内容", &#123;flag: "w"&#125;, function (err) &#123; if (err) &#123; console.error(err); &#125; console.log("追加成功了");&#125;); 复制文件复制文件的原理则是先读取出文件的内容在写入到另外一个文件之中12345678910111213141516171819202122// 复制文件(异步)function copy (src, dest) &#123; fs.readFile(src, "utf-8", function (err, data) &#123; if (err) &#123; console.error(err); return; &#125; fs.writeFile(dest, data, function (err) &#123; if (err) &#123; console.error(err); return; &#125; console.log("复制成功"); &#125;) &#125;);&#125;;// 复制文件(同步)function copy (src, dest) &#123; fs.writeFileSync(dest, fs.readFileSync(src, "utf-8"), "utf-8");&#125;copy("test.txt", "test2.txt"); 目录操作创建目录12345678var fs = require("fs");// 第二个参数为权限的设置，它是一个3位8进制数，每一位数字由1，2，4组成，1是可执行、2是可写、4是可读fs.mkdir("test", 0555, function (err) &#123; if (err) &#123; console.error(err); &#125; console.log("创建成功");&#125;); 删除目录123456fs.rmdir("test", function (err) &#123; if (err) &#123; console.error(err); &#125; console.log("删除成功");&#125;); 读取目录输出该目录下除了.和..的所有文件组成的数组1234567fs.readdir("./", function (err, files) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log(files); &#125;&#125;); 查看文件或者目录详情1234567fs.stat("./test.txt", function (err, stat) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log(stat); &#125;&#125;); 判断文件是否存在1234fs.exists("test", function (exists) &#123; console.log(exists); // 如果存在回调为TRUE，反之为FALSE&#125;); 相对路径获取绝对路径1234567fs.realpath("test", function (err, path) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(path); // path即为获取到的绝对路径 &#125;&#125;); 修改文件名1234567fs.rename("test", "newTest", function (err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log("重命名成功"); &#125;&#125;); streamstream:流，它的出现是为了处理大数据，把一个大的文件截取成若干个大小为64K的小文件存储12345var fs = require("fs");function copy(src, dest) &#123; fs.writeFileSync(dest, fs.readFileSync(src));&#125;copy("1.png", "2.png"); 上面是一个对文件拷贝的代码，看似没什么问题，也的确在处理小文件的时候没什么大问题，但是一旦处理数量级很大的文件的时候可以看出，先将数据读取出来，在写入，内存作为中转，如果文件太大就会产生问题。如果是大文件就得使用file system的另外几个API，createReadStream和createWriteStream，将文件作为一块一块小的数据流进行处理，而不是一整块大型数据。123456789101112131415161718// 创建可读流var rs = fs.createReadStream("1.png");// 创建可写流var ws = fs.createWriteStream("4.png");//每一个可读流具有data事件var times = 0;rs.on("data", function (chunk) &#123; // 每64k会触发一次事件 times ++; // console.log(times); // console.log(chunk); ws.write(chunk, function () &#123; // console.log("chunk写入成功"); &#125;);&#125;);rs.on("end", function () &#123; console.log(times);&#125;); 当然上面的方法也可能产生内存爆仓，写入速度跟不上读取速度，一直读取的文件不断放入内存中，但是两个的操作的速度是肯定不一样的，导致未被写入的数据在内存中越来越大，才会是内存爆仓。node中有一个较为简便的解决方法：pipe管道连接1rs.pipe(ws); pathpath：里面封装了一些对文件的路径的操作可以使用normalize规范化字符串路径123var path = require("path");var pathstr = "a/../b/./c/../d/f/./e";console.log(path.normalize(pathstr)); // 打印结果为b/d/f/e __dirname显示当前绝对路径1console.log(__dirname); join将多个参数值字符串结合成一个路径字符串1console.log(path.join(__dirname, "a", "..b", "..c/e/./d", "text.txt")); resolve把一连串的路径解析成绝对路径1console.log(path.resolve("baidu", "a/..", "n/..", "test.html"));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js基础（一）]]></title>
      <url>%2F2017%2F03%2F16%2Fnode.js%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[什么是node.jsJavaScript是一个脚本语言，脚本语言都需要一个解析器才能运行，但是node.js采用C++语言编写而成，是一个Javascript的运行环境。既然不是Javascript应用，为何叫.js呢？因为Node.js是一个Javascript的运行环境。作为Web前端最重要的语言之一，Javascript一直是前端工程师的专利。不过，node.js是一个后端的Javascript运行环境，这意味着你可以编写系统级或者服务器端的Javascript代码，交给Node.js来解释执行。node.js采用了Google Chrome浏览器的V8引擎，性能很好，同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的Javascript代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，Node.js则是一个全面的后台运行时，为Javascript提供了其他语言能够实现的许多功能。它的三大特征：模块化，异步编程，事件驱动 实现http服务器使用node.js来实现第一个http服务器，博主是用WebStrom编译器来编译的1234567891011121314// 需要引入node的原生模块"http"var http = require("http");http.createServer(function (req, res) &#123;/** req: require, 包含一些URL信息，以及传入的数据* res: response, 包含请求回应的状态码，返回的信息等等* req.url "/" 根目录* req.method "GET" 请求方式* */ // 设置输出文本编码格式为中文 res.writeHead(200, &#123;"Content-Type": "text/html;charset=utf-8"&#125;); // end不只是输出返回的内容，还代表本次请求的结束，它只能输出字符串 res.end("我是请求回应的文本");&#125;).listen(8080); // 设置本服务器的端口号 模块化可以参考http://www.cnblogs.com/dolphinX/p/4381855.html 为什么会有模块？在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可。如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码 模块的好处既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可import java.util.ArrayList;遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了。 commonjs规范CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。CommonJS能有一定的影响力，我觉得绝对离不开node.js的人气，不过，node.js，CommonJS，浏览器甚至是W3C之间有什么关系呢，如下图所示： 引入url模块解析路径12345678910var http = require("http");var url = require("url"); // 原生URL模块var server = http.createServer(function (req, res) &#123; res.writeHead(200, &#123;"Content-Type": "text/html; charset=utf-8"&#125;); // parse(路径, 第二个参数为将请求参数解析为对象) var urlObj = url.parse(req.url, true); // 第二个参数为true表示将内层的数据也给转换成对象 console.log(urlObj); res.end();&#125;);server.listen(8080); 创建自定义模块加载当前目录的模块不加var的变量是全局变量，在模块内部最好加var。要导出一个属性或者方法使用: module.exports如果是模块下的方法和属性使用: module.exports={xx:xx};如果是想让模块直接接受方法就导出函数例如：12345678910var a = 5; // 模块里的变量一定要加上varfunction addX(x) &#123; console.log(a + x);&#125;// 输出该模块的属性和方法// module.exports = &#123;// a: a,// addX: addX// &#125;;module.exports = addX; 加载非当前目录的模块首先会看当前目录是否有一个node_modules，如果有就看进入里面查找是否有叫模块名称的文件或者是否有叫模块名称的文件夹。如果是模块名称的文件夹需要看一下文件夹内部是否有index.js或者package.json中是否有设置mian属性。如果当前目录中没有node_modules，会向上查找。可以通过：console.log(module);输出 加载原生模块 扩展非node项目中也可以使用模块化开发技术，用得比较多的模块加载器有：requirejs(CMD),seaJs(AMD)。 npm它是包（一组模块的集合）。npm作为node的包管理器 repl(交互式解释器)REPL(Read Eval Print Loop:交互式解释器)概念表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。进入repl方式：终端中键入node。 repl处理表达式运算可以进行简单的加减乘除运算，也可以使用变量甚至编写for循环while语句等等可以使用下划线(_)获取表达式的上一次的运算结果 REPL 命令123456ctrl c 退出当前终端。ctrl+c 按下两次，退出 Node REPLctrl d 退出node REPL，向上/向下键，查看输入的历史命令tab 列出当前命令help 列出使用命令break 退出多行表达式clear 退出多行表达式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的一些基本知识 -- 函数]]></title>
      <url>%2F2017%2F03%2F11%2FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%20--%20%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[JavaScript的基本函数函数的定义方法1.静态方法function 函数名 (参数) {code….};函数定义之后不会立即执行{}里面的代码，而是会等到调用的时候才会执行。 2.匿名方法var 函数名 = function (参数) {code….}; 3.直接量方法函数名 = function (参数) {code….}; 函数的参数参数的类型形式参数形参不会改变实参的值定义函数时使用的参数 实际参数调用函数时传递给函数的实际参数 参数的特性函数的参数没有个数限制参数的数据类型也没有限制通过arguments对象访问函数参数的数组参数始终按值传递 函数的arguments对象arguments对象是存放函数实际参数的参数列表它只能在函数内部使用，它不是数组，但是带有下标属性每次函数声明时它会自动初始化它有三个基本属性：1.length获取实际参数的长度2.callee返回当前正在指向的函数3.caler返回调用当前正在执行函数的函数名 函数的类型1.有参数有返回值2.无参数无返回值3.有参数无返回值4.无参数有返回值 函数的指针标识this指向当前操作对象 callee指向参数集合所属函数 prototype指向函数附带的原型对象 constructor指向创建该对象的构造函数 函数的调用方法1.在事件中调用事件类型 = 函数名(); 2.直接调用函数名(); 3.自执行**(function (){})(); 4.在连接中调用 函数的回调把函数2当做参数传到函数1里面，在函数1里面调用函数2，就叫函数回调。 函数的返回值函数里面写了return之后，下面不能写代码，不会被执行当调用这个函数之后，可以接收到什么东西。可以在函数里面通过return 返回值名来返回 函数的闭包函数内部的函数就是闭包闭包的两个基本作用：1.每次访问函数1得到的函数2的函数是不一样的函数。他们的空间不是同一块内存空间2.通过闭包可以访问函数内部的局部变量 函数的递归在函数内部调用自己这个函数，这样会形成一个死循环，所以使用递归的时候必须给程序一个出口。博主自己整理的一些JavaScript中函数的基本知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的一些基本知识 -- DOM操作]]></title>
      <url>%2F2017%2F03%2F02%2FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%20--%20DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[Dom基本操作获取节点一、document1.querySelectorAll根据CSS里面的选择器来获取一组元素(获取的是数组)用法：document.querySelectorAll(“选择器”);选择器可以是后代选择器，群组选择器，nth-child(1)等等获取的数组不会随着dom的操作发生变化而变化 2.querySelector获取querySelectorAll获取到的第一个元素用法：document.querySelector(“选择器”); 3.通过元素ID获取节点用法：document.getElementById(“元素ID”); 4.通过类名获取节点用法：document.getElementsByClassName(“元素类名”);通过类名获取节点(获取的是动态数组)动态数组会跟随dom操作发生变化之后做出相应的变化 5.通过元素标签名获取节点用法：document.getElementsByTagName(“元素标签名”);通过元素标签名获取的也是动态数组 6.通过name属性来获取节点用法：document.getElementsByName(“name值”);通过name属性获取的也是动态数组 二、节点指针1.获取元素的首个子节点用法：父节点.firstChild; 2.获取元素的最后一个子节点用法：父节点.lastChild; 3.获取元素的子节点列表用法：父节点.childNodes; 4.获取已知节点的前一个节点用法：兄弟节点.previousSibling; 5.获取已知节点的后一个节点用法：父节点.nextSibling; 6.获取已知节点的父节点用法：父节点.parentNode; 节点操作一、创建节点1.创建属性节点用法：document.createAttribute(“创建的元素属性”); 2.创建文本节点用法：document.createTextNode(“创建的文本内容”); 3.创建元素节点用法：document.createElement(“创建的元素标签名”); 二、删除节点删除指定的节点用法：removeChild(要删除的节点名); 三、替换节点将某个子节点替换为另一个用法：replaceChild(新节点, 原节点); 四、插入节点1.向节点的子节点列表的末尾添加新的子节点用法：appendChild(所添加的新节点); 2.在已知的子节点前插入一个新的子节点用法：insertBefore(新节点, 原节点) 五、复制节点复制节点标签用法：cloneNode(bool);哪个节点调用就复制哪个，true代表深复制，会复制子节点树，false代表浅复制，只复制本身 节点属性一、获取属性获取元素节点中指定属性的属性值用法：元素节点.getAttribute(元素属性名); 二、设置属性创建或改变元素节点的属性用法：元素节点.setAttribute(属性名, 属性值); 三、删除属性删除元素中的指定属性用法：元素节点.removeAttribute(属性名); 文本操作1.从指定的位置插入字符串用法：insertData(offset, string); 2.从指定的位置起删除一些字符用法：deleteData(offset, count); 3.将字符串插入到文本尾部用法：appendData(string); 4.从指定的位置起将文本节点分成两个节点用法：splitData(offset); 5.从指定的位置起将一些字符用其他字符串代替用法：replaceData(offset, count, string); 6.从指定的位置起返回一些节点用法：substringData(offset, count);博主自己整理的一些JavaScript中Dom的基础知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的一些基本知识 -- 数组]]></title>
      <url>%2F2017%2F03%2F01%2FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%20--%20%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[JavaScript的数组数组的创建方法1.创建空数组1var arr = new Array(); 2.创建指定元素的数组1var arr = new Array(元素1, 元素2…); 3.单维数组1var arr = [元素1, 元素2...]; 4.多维数组1var arr = new Array([数组1], [数组2]…); 数组的长度array.length返还数组的长度 数组的基本操作获取数组元素注意：数字的下标是从0开始计算的！ 单维数组数组名[下标索引值] 多维数组数组名[外层下标索引值][内层下标索引值] 增加数组使用“[]”指定一个新的下标 删除数组delete 数组名[下标]; 遍历数组使用for…in…来遍历1for (var i in Array) 数组的一些方法添加1.在数组末尾添加数组push(); 2.在数组头部添加数组unshift(); 删除1.从数组头部删除一个元素shift(); 2.从数组尾部删除一个元素pop(); 截取slice(起始位置, 结束位置);两个参数分别代表要获取的数组的起始位置和结束位置。可以用-1代表倒数第一个，-2代表倒数第二个 splice方法①.splice(起始位置，删除的长度)例如：123var math = [90, 88, 30, 45, 54, 98, 66, 76];math.splice(0, 2);console.log(math); // 打印结果为[30, 45, 54, 98, 66, 76] ②.splice(起始位置,删除长度为0,要添加的元素1,要添加的元素2…..）例如123var math = [90, 88, 30, 45, 54, 98, 66, 76];math.splice(0, 0, 10, 12,65);console.log(math); [10, 12, 65, 90, 88, 30, 45, 54, 98, 66, 76] 排序排序不按照数值大小，而是把元素看出一个字符串，按照首字母来排sort();将数组中元素的顺序颠倒reverse(); 拼接concat();数组拼接，数组不会在原有的数组上进行拼接，而是返回一个拼接之后的新数组。123456var test = [1, 2, 3]var test2 = [4, 5, 6]var a = test.concat(test2);console.log(test); // [1, 2, 3]console.log(test2); // [4, 5, 6]console.log(a); // [1, 2, 3, 4, 5, 6] 转换使用数组的join();方法，可以把这个数组用一个字符串来连接起来，然后返回一个新的字符串，原来的数组不会发生变化。 数组小结博主自己整理的一些JavaScript中数组的知识 注意点数组直接赋值的时候是-地址引用基本数据类型赋值是-值拷贝对象类型赋值是-地址引用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的一些基本知识 -- 字符串]]></title>
      <url>%2F2017%2F02%2F28%2FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%20--%20%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[JavaScript的字符串转化为字符串toString();12var num = 10;var str = num.toString(); 创建字符串1var str = new String(&quot;123456&quot;); 查找方法1.charAtcharAt();去字符串里面寻找下标为括号内传入的参数的字符，从零开始，空格也算做字符。12var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;console.log(str.charAt(15)); // 打印结果为m 2.searchsearch();在字符串中，搜索某个单词，然后返回这个单词在字符串中首字母的位置，搜索不到返回 -1，出现多个匹配的字符串之后，只返回第一个的位置。12var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;console.log(str.search(&quot;you&quot;)); // 打印结果为8 3.indexOfindexOf();从前往后获取字符串的位置，如果没有则返回-112var str = &quot;adssddsssdfsa&quot;;console.log(str.indexOf(&quot;a&quot;)); // 打印结果为0 4.lastIndexOflastIndexOf();从后往前从前往后获取字符串的位置，如果没有则返回-112var str = &quot;adssddsssdfsa&quot;;console.log(str.lastIndexOf(&quot;a&quot;)); // 打印结果为12 截取字符串substringsubstring(起始位置, 结束位置);截取字符串，给一个参数的时候代表，从这个位置开始，截取到字符串结束。给两个参数的时候，一个代表起始位置，一个代表结束位置(不包含最后一个位置)。123var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;var str2 = str.substring(4, 11);console.log(str2); // 打印结果为are you substrsubstr(起始位置, 截取长度);截取字符串，第一个参数代表其实位置，第二个字符串代表截取的长度。123var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;var str2 = str.substr(4, 7);console.log(str2); // 打印结果为are you 替换字符串replacereplace(替换的值, 被替换的值);字符串替换，把前面的替换成后面的，只会替换第一个。12var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;var str2 = str.replace(&quot;you&quot;, &quot;ni&quot;); splitsplit();把一个字符串按照参数分割成N个元素的数组。12var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;var str2 = str.split(&quot;,&quot;); // 打印结果为[&quot;how are you&quot;, &quot; i&apos;m fine thank you&quot;, &quot; and you&quot;] 字符串的拼接concatconcat();将一个字符串或多个字符串拼接起来，获得一个新的字符串123var str = &quot;how are you, i&apos;m fine thank you, and you&quot;;var str2 = &quot;--------Hello!&quot;;console.log(str.concat(str2)); // 打印结果为how are you, i&apos;m fine thank you, and you--------Hello! 字符串的转换方式toLowerCasetoLowerCase();方法返回一个字符串，该字符串中的字母被转换成小写。 toUpperCasetoUpperCase();方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。 字符串小结博主自己整理的一些JavaScript中字符串的知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax的探索]]></title>
      <url>%2F2017%2F02%2F24%2FAjax%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[什么是AjaxAjax的全称是Asynchronous JavaScript And XML(异步Javascript和XML)。它不是一项新的技术，而是由多种技术组合而成。 Ajax的关键技术1.Javascript脚本语言2.XMLHttpRequest对象3.可扩展标记语言(XML) JSON4.文档对象模型(DOM)5.层叠样式表(CSS) 前后台通讯封装一个Ajax的方法这里名字为GetAndPost.js内容展示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function toUrl(url,data)&#123; var time = new Date().getTime(); data.time = time; var arr = []; ///存储经过遍历之后形成的名和值的字符串 for(var i in data)&#123; var str = i + &quot;=&quot; + data[i]; arr.push(str); &#125; var str = arr.join(&quot;&amp;&quot;); var path = url + &quot;?&quot; + str; return path;&#125;function fnAjax(obj)&#123; // 兼容浏览器写法 if (window.XMLHttpRequest) &#123; var ajax = new XMLHttpRequest(); &#125; else &#123; var ajax = new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;); &#125; var data = obj.data || &#123;&#125;; var succFn = obj.succFn || false; var failFn = obj.failFn || false; var path = toUrl(obj.url,data); var pathArr = path.split(&quot;?&quot;); var time = new Date().getTime(); var type = obj.type || &quot;get&quot;; if (type == &quot;get&quot;) &#123; ajax.open(&quot;GET&quot;, path, true); ajax.send(null); &#125; else &#123; ajax.open(&quot;POST&quot;, pathArr[0], true); ajax.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); ajax.send(pathArr[1]); &#125; // 对状态的检测 ajax.onreadystatechange = function()&#123;// console.log(ajax.readyState); //当前的请求状态 if (ajax.readyState == 4) &#123; // console.log(&quot;请求成功了&quot;); // console.log(ajax.status); //请求结果的状态码 if (ajax.status &gt;= 200 &amp;&amp; ajax.status &lt;= 207 || ajax.status == 304) &#123; if (succFn) &#123; succFn(ajax.responseText); &#125; &#125; else &#123; if (failFn) &#123; failFn(ajax.status); &#125; &#125; &#125; &#125;;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础(四)]]></title>
      <url>%2F2017%2F02%2F24%2FPHP%E5%9F%BA%E7%A1%80(%E5%9B%9B)%2F</url>
      <content type="text"><![CDATA[PHP的文件上传这里还是举例子说明创建两个页面，一个fileup.html和一个fileup.phpfileup.html代码如下：12345678910111213141516&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--enctype是设置编码格式的--&gt; &lt;form action=&quot;fileup.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!--限制上传的最大大小--&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; id=&quot;MAX_FILE_SIZE&quot; value=&quot;300000&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;fileup&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; fileup.php代码如下：1234567891011121314151617181920212223242526272829&lt;?php date_default_timezone_set(&apos;PRC&apos;); // 设置默认时区 $file = $_FILES[&quot;fileup&quot;]; // 根据错误码，判断是否上传成功 if ($file[&quot;error&quot;] == 0) &#123; // 根据类型判断是图片还是其他 $imgArr = array(&quot;image/jpeg&quot;,&quot;image/png&quot;,&quot;image/gif&quot;); if (in_array($file[&quot;type&quot;], $imgArr)) &#123; $type = explode(&quot;/&quot;, $file[&quot;type&quot;])[1]; if ($type == &quot;jpeg&quot;) &#123; $type = &quot;jpg&quot;; &#125; $time = time(); // 时间戳，以秒为单位 $time = date(&quot;YmdHis&quot;, $time); // 设置显示时间的格式 // 若要放到其他文件夹 $name = &quot;../2.21php4/&quot;.$time.&quot;.&quot;.$type; $bol = move_uploaded_file($file[&quot;tmp_name&quot;], $name); if ($bol) &#123; echo &quot;移至服务器成功&quot;; &#125; else &#123; echo &quot;移至失败&quot;; &#125; &#125; else &#123; echo &quot;不是图片&quot;; &#125; &#125; else &#123; echo &quot;上传失败&quot;; &#125;?&gt; PHP的正则表达式查找匹配1234$reg = &quot;/\d+/&quot;;$str = &quot;asda4 244g h64 485 14&quot;;echo preg_match($reg, $str); // 返回匹配的次数echo preg_match_all($reg, $str); // 返回匹配次数，多次匹配 替换匹配123$reg = &quot;/\d+/&quot;;$str = &quot;asda4 244g h64 485 14&quot;;$str = preg_replace($reg, &quot;*&quot;, $str); 分隔字符串1234$reg = &quot;/\d+/&quot;;$str = &quot;asda4 244g h64 485 14&quot;;$arr = preg_split(&quot;/\s/&quot;, $str);var_dump($arr); 小练习返回数组中能与正则进行匹配的每一项，并以数组进行输出123$arr = array(&quot;514ada&quot;, &quot;Asda5a153&quot;,&quot;awda6531&quot;);$str = preg_grep(&quot;/\d+/&quot;, $arr);var_dump($str); mysql数据库PS：博主用的是XAMPP自带集成的MySql 第一步 连接数据库参数分别为主机名，用户名，密码1234567$mysql = mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;);if (!$mysql) &#123; echo &quot;连接失败&quot;; exit(); // 退出后面的执行&#125; else &#123; echo &quot;连接成功&quot;;&#125; 第二步 选择需要的数据库mysql_select_db(“20170222”); // 数据库名mysql_query(“set names utf8”); // 编码格式设置为utf-8 第三步 进行增删改的操作1）查询语句1234567// SELECT（字段名） FROM （数据表名）（查询的限制条件）$sql = &quot;SELECT * FROM userinfo&quot;;// 限制条件有WHERE语句，LIMIT语句，ORDER BY语句// 例：$sql = &quot;SELECT * FROM userinfo WHERE id=3&quot;;// $sql = &quot;SELECT * FROM userinfo LIMIT 1, 2&quot;; 1表示从第二条查找，2表示查找出来两条// $sql = &quot;SELECT * FROM userinfo ORDER BY age asc&quot;; 按照年龄升序，asc是默认的升序$result = mysql_query($sql); 2） 插入语句1$sql = &quot;INSERT INTO userinfo (id, user, pass, age, sex) VALUES (NULL, &apos;测试&apos;, &apos;test&apos; , 100, &apos;男&apos;)&quot;; 3） 更新语句1$sql = &quot;UPDATE userinfo SET username = &apos;admin1&apos;, passwd =&apos;12345678&apos; WHERE id = 10; 4） 删除语句1$sql = &quot;DELETE FROM user WHERE id = 10&quot;; 第四步 对操作结果进行处理1） 以索引数组的形式输出while ($arr = mysql_fetch_row($result)) { var_dump($arr);} 2） 以关联数组形式进行返回while ($arr = mysql_fetch_assoc($result)) { var_dump($arr);} 3） 以关联数组和索引数组的形式输出while ($arr = mysql_fetch_array($result)) { var_dump($arr);} 4） 以对象的形式进行输出while ($obj = mysql_fetch_object($result)) { var_dump($arr);} 第五步 关闭数据库mysql_close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac搭建一个属于自己的hexo博客(github page)]]></title>
      <url>%2F2017%2F02%2F22%2Fmac%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[1.本地环境的安装安装node.jsnode.js的官网 安装gitgit的官网 安装hexohexo是基于node.js的静态博客。在你想创建博客的路径下创建一个blog文件夹（这里文件名随意）。然后打开MAC电脑的终端，进入到这个文件夹(博主是创在根目录下所以直接cd blog就能进入)接着输入$ sudo npm install -g hexo;此时hexo已经装好了，再输入$ hexo init初始化文件夹会将github上的所有hexo的初始化项目下载到该文件夹下1INFO Start blogging with Hexo! 显示这行代码就说明初始化成功了此时我们可以先试一下输入$hexo g部署形成文件然后等它部署好之后再输入$hexo s开启本地测试（退出就按Ctrl+C）此时打开浏览器输入http://localhost:4000/，可以进行查看我们的初始页面效果如下：至此，我们的环境都已经安装完成了，让我们进行下一步吧！ 2.注册github如果已经有账号了可以直接往下看，打开github官网进行注册登录登录之后出现如下界面，点击Start a project然后在Repository name中填入你的Owner的用户名在加上.github.io，然后这就是你的域名了（这里由于博主已经创建过一个一样的库了所以提示错误），然后点击下面的按钮接着点击页面右上角你的头像选择your profile进入下面页面，选择刚才创建的库进入之后选择Settings选项卡，下拉至GitHub Pages栏目中将Source里选择master branch，如果已经是这个选项，就不需要更改 3.配置Github SSH keys我们需要给我们的MAC添加SSH Keys，让Github能够绑定到我们这台电脑上，能够直接提交传送修改项目。 ①.首先先查看一下本机是否有过SSH KEY的设置在终端输入cd ~/.ssh 或cd .ssh如果是第一次设置则会显示No such file or directory如果有配置过则进入~/.ssh路径下输入ls查看当前路径文件，再用rm*删除所有文件 ②.设置SSH KEY在终端中进行如下配置：123456789101112131415161718192021222324252627282930313233343536$ cd ~ #保证当前路径在”~”下$ ssh-keygen -t rsa -C &quot;xxxxx@xx.xxx&quot; #引号里将xxx换成你注册的邮箱地址Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /Users/xxxx/.ssh/id_rsa. #生成的密钥Your public key has been saved in /Users/xxx/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:SHA256:plEUOl2Syg3KprBZYAwCuxa7V2ELo2GqCaAg3ERnY0M xxxxxxx@xxx.xxxThe key&apos;s randomart image is:+---[RSA 2048]----+|B .o.E +o. ||++o + ++.o ||** = =o+o ||O.* B =o. ||=O o o. S ||*.o . + ||o. . . || . || |+----[SHA256]-----+$ vim ~/.ssh/id_rsa.pub #编译代码 将上面图形转换成代码ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+7F3/3/gA6GFwKyhIONc+fZu5Re/Y2SzeGRNbg/qxxxx5KrQw/JxxxA2qh7xxxxxxxxxxxxpXBiIn+7MI4Pfd9ZaUFfjQ7fQPNhZ1gs1GFtLXTaJ2RAvnBY6/hqPxkQqp8qkOaEbUtyrKciW+YXs/Qux/d2hnwj3F/dvfQ5JjFlbBNydkNJKat3wU7BKL5TIffMPzdnL/Ir5y0h5apcp4l0wruQzkXKHcMgI4ltYqOscqu4nawzZII3wiwxAcFd+0BeboCs+BP7U/iXpKyxOa9Br8sFMU/q7O/i7RcBufEg5W9wxkWB3i0QRmRyctLOj8yvXCBM4KnL6Amz xxxxxx@xxxx.xxxx~~~# 这是已经生成好ssh key，其存放路径为：/Users/你电脑的用户名/.ssh/下。# 可以直接将ssh-rsa至@xxxx.xxxx这一大段复制下来 ③.绑定Github上的SSH KEY返回刚才的Github页面点击右上角的头像边上的小三角选择Settings在左侧选择SSH and GPG Keys栏，然后点击News SSH KeyTitle里可以自定义填入，Key里就把之前从”ssh-rsa至xxxxx@xxxx.xxxx”这一大串复制进去，然后点击Add SSH Key即可添加完成 ④.配置用户名和邮箱返回终端进行如下操作设置你的用户名和邮箱地址：12$ git config --global user.name “your_username” #引号里设置用户名$ git config --global user.email “your_registered_github_Email” #引号里设置设置邮箱地址(建议用注册giuhub的邮箱) ⑤.检测SSH Key是否配置成功在终端输入$ssh -T git@github.com出现如下字段则说明配置成功Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.至此我们已经完成了与github的绑定 4.设置hexo博客的配置文件找到你创建的博客的位置，打开其文件夹下的_config.yml文件将其拉到最后找到deploy字段，进行如下设置：1234deploy: type: git repository: https://github.com/你自己的Github用户名//你自己的Github用户名/.github.io branch: master 如果想了解更多可以查看hexo官网 5.上传博客这里我们需要安装一下git的上传代码插件进入终端输入$ npm install hexo-deployer-git --save接着我们就可以上传我们的博客了依次输入1234$hexo clean #清除网页的缓存$hexo g #生成静态页面至public目录$hexo s #会开通本地测试的接口$hexo d #将.deploy目录部署到GitHub 如果最后出现INFO Deploy done: git则说明上传成功 此时就大功告成了！你可以去打开浏览器访问一下你创建的Github pages地址(你的Github用户名.github.io)，然后就能够看到你本地的hexo博客已经被部署到github上去了。而且此时博客的默认主题是landscape，就是之前本地测试时的样子，如果想要更换主题可以访问hexo的主题 6.发布文章在终端输入$hexo new &quot;文章名&quot;然后就能看到在你博客文件夹下的/source/_posts/下面会看到你新建的博客注意这里的博客是markdown格式的以.md为后缀名的文件，如果想学习下怎么使用可以查询一下markdown的书写格式，同时markdown也是兼容html的书写方式。文章写完之后在终端输入12$hexo g$hexo d 重新发布即可！ 7.小结博主整理了下全部流程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP制作一个用户登记表]]></title>
      <url>%2F2017%2F02%2F22%2FPHP%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%99%BB%E8%AE%B0%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[展示单行的用户信息表首先我们需要创建两个文件，一个为html文件，一个为php文件。这里博主就创建了form.html和formHandle.php两个文件。下面展示一下两个文件的内容：form.html的文件内容：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;test.php&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot; value=&quot;&quot; /&gt;&lt;br/&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女&lt;br/&gt; 兴趣：&lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;0&quot; /&gt;写代码 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;1&quot; /&gt;修改代码 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;2&quot; /&gt;上传代码&lt;br/&gt; 城市：&lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;0&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;杭州&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 简介：&lt;textarea name=&quot;intro&quot;&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果展示：这里要注意的是类似性别，兴趣，城市这三类我们可以用value数值传入0，1，2来代表用户分别选的不同的选项。兴趣部分，因为是多选，所以我们需要传入一个数组来方便我们展示，所有name属性写的是hobby[]来记录。formHandle.php的文件内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php $inf = $_GET;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;兴趣&lt;/td&gt; &lt;td&gt;城市&lt;/td&gt; &lt;td&gt;简介&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $inf[&quot;user&quot;] ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $inf[&quot;pass&quot;] ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php $sexArr = array(&quot;男&quot;,&quot;女&quot;); echo $sexArr[$inf[&quot;sex&quot;]]; ?&gt; &lt;/td&gt; &lt;td&gt;&lt;?php $hobbyArr = array(&quot;写代码&quot;,&quot;修改代码&quot;,&quot;上传代码&quot;); foreach ($inf[&quot;hobby&quot;] as $value) &#123; echo $hobbyArr[$value].&quot; &quot;; &#125; ?&gt; &lt;/td&gt; &lt;td&gt;&lt;?php $cityArr = array(&quot;上海&quot;,&quot;杭州&quot;); echo $cityArr[$inf[&quot;city&quot;]]; ?&gt; &lt;/td&gt; &lt;td&gt;&lt;?php echo $inf[&quot;intro&quot;] ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 接下来我们来测试一下：最终效果为：这里博主提问一个问题，以上方法每次只能够保存一个用户的信息，如果想展示多行的用户信息该怎么办呢？ 展示多行的用户信息表有经验的后台人士就会说了这时候就需要一个数据库来存入信息了，这里由于博主也是刚学PHP，就用txt文件来代替一下数据库了。这里form.html中的&lt;form action=&quot;test2.php&quot; method=&quot;get&quot;&gt;然后建立一个text2.php文件，再建立一个存储用户信息的userinfo.txt和相对应做操作的userinfo.php两个文件，一共三个文件。text2.php的文件内容：123456&lt;?php $str = json_encode($_GET); $fh = fopen(&quot;userinfo.txt&quot;, &quot;a&quot;); fwrite($fh, $str.&quot;\n&quot;); fclose($fh); ?&gt; 这里面由于用户提交到后台的信息为数组所以需要转换成json类型的字符串，用到了json_encode();的方法，再把用户提交的个人信息保存到userinfo.txt的文件中。 userinfo.php的文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php // 用户信息的展示页 （把信息存文件里读取出来） $fh = fopen(&quot;userinfo.txt&quot;, &quot;r&quot;);?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt;城市&lt;/td&gt; &lt;td&gt;简介&lt;/td&gt; &lt;/tr&gt; &lt;?php while ($info = fgets($fh)) &#123; $info = (array)json_decode($info); ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $info[&quot;user&quot;]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $info[&quot;pass&quot;]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php $sexArr = array(&quot;男&quot;, &quot;女&quot;); echo $sexArr[$info[&quot;sex&quot;]]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php $loveArr = array(&quot;听音乐&quot;, &quot;看书&quot;, &quot;打球&quot;); foreach ($info[&quot;love&quot;] as $value) &#123; echo $loveArr[$value]; &#125; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php $cityArr = array(&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;); echo $cityArr[$info[&quot;city&quot;]]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $info[&quot;intro&quot;]; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 这下可以尝试在form.html页面多输入几个用户的信息 展示效果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础(三)]]></title>
      <url>%2F2017%2F02%2F21%2FPHP%E5%9F%BA%E7%A1%80(%E4%B8%89)%2F</url>
      <content type="text"><![CDATA[PHP文件的操作 打开文件$fh = fopen("test.txt", "a"); 读取文件1.fread$str = fread($fh, filesize("test.txt")); filesize是获取文件的大小，返回的类型是字符串 2.fgets fgets只返回一行，返回的类型也是字符串再次返回就从下一行开始 $str = fgets($fh);$str = fgets($fh); 3.file注意file返回的类型是数组 $arr = file("test.txt"); 4.file_get_contents用file_get_contents获取文件内容，也会返回出字符串，还可以用绝对路径打开一个网页 $str = file_get_contents("test.txt");$str = file_get_contents("https://www.baidu.com"); 文件写入1.fwritefwrite($fh, "我是写入的内容"); 2.file_put_contentsfile_put_contents("test.txt", "我是put进去的"); 关闭文件fclose($fh); 复制文件copy(需要复制的文件, 新的文件名);copy(&quot;test.txt&quot;, &quot;test2.txt&quot;); 重命名文件rename(原文件名, 新文件名);rename(&quot;test2.txt&quot;, &quot;rename.txt&quot;); 删除文件unlink(需要删除的文件名);unlink(&quot;test.txt&quot;); PHP获取PV什么是PV？PV（page view）即页面浏览量这里博主介绍一下最简单的记录PV的原理以及方法原理：通过判断是否存在记录pv量的文件，如果没有就创建，并在文件里写入1，如果有，就获取文件里的数值，并加1，再写入文件。123456789if (file_exists(&quot;pv.txt&quot;))&#123; $str = file_get_contents(&quot;pv.txt&quot;); $str++; echo &quot;当前的PV量是&quot;.$str; file_put_contents(&quot;pv.txt&quot;, $str);&#125; else &#123; echo &quot;当前的pv量是1&quot;; file_put_contents(&quot;pv.txt&quot;, 1);&#125;PHP对文件目录的操作 打开目录$dh = opendir("."); 读取文件如同fgets，第一次只读取第一个，第二次到第二个依次类推$str = readdir($dh);可以使用while循环来读取123while ($file = readdir($dh)) &#123; echo $file.&quot;&lt;hr/&gt;&quot;;&#125; 将目录以数组的形式全部返回出来 $fileArr = scandir("."); print_r($fileArr); 关闭目录closedir($dh); 创建文件mkdir("test"); 删除文件rmdir(“test”); 以表格的形式展示出文件目录这里博主就不多说了直接上例子！123456789101112131415161718192021&lt;?php $dh = opendir(&quot;.&quot;);?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;?php while ($file = readdir($dh)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&#123;$file&#125;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; ?&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;这种方式运行出的结果是一样的1234567891011121314151617181920212223&lt;?php $dh = opendir(&quot;.&quot;);?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;?php while ($file = readdir($dh)) &#123; ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $file; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;第三种显示目录的方式123456789101112131415161718192021222324252627282930&lt;?php @$url = $_GET[&quot;url&quot;]; // @符号可以抑制报错，前提是这个错误不影响整个程序运行 echo $url; if ($url) $dh = opendir($url); else $dh = opendir(&quot;.&quot;); ?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;?php while ($file = readdir($dh)) &#123; ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $file; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt; &lt;a href=&quot;showDir3.php?url=..&quot;&gt;链接到上一层&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;PHP文件目录的一些操作 获取上一次的访问时间fileatime();1234date_default_timezone_set(&apos;PRC&apos;); // 设置默认时区$time = fileatime(&quot;file.php&quot;); // 时间戳单位是秒$time = date(&quot;Y-m-d H:i:s&quot;, $time); // 设置打印出来的时间的格式echo $time; 获取上一次的修改时间filemtime();123$time = filemtime(&quot;file.php&quot;); // 时间戳单位是秒$time = date(&quot;Y-m-d H:i:s&quot;, $time); // 设置打印出来的时间的格式echo $time; 获取上一次Innode的修改时间filectime();ps:Innode包括修改权限等等123$time = filectime(&quot;file.php&quot;); // 时间戳单位是秒$time = date(&quot;Y-m-d H:i:s&quot;, $time); // 设置打印出来的时间的格式echo $time; 获取文件名basename();注意它获取的是一个文件的文件名+后缀扩展名1234$path = $_SERVER[&apos;REQUEST_URI&apos;]; // 获取服务器中的文件路径$path = __FILE__; // 获取服务器根路径文件路径$basename = basename($path); // 获取文件名print_r(pathinfo($path)); // 返回的是数组 PHP文件的权限修改chomd();用法：chomd(文件，八进制组成的权限)权限由4位八进制组成，第一个是0，表示这是一个八进制，第二位代表是所有者的权限，第三位是所有者所在组的权限，第四位是任何人的权限，权限有1，2，4组成，可累加进行权限的叠加，1代表可执行权限、2代表可写权限、4代表可读权限例如要设置所有者可读可写，所有者所在组可执行可写，任何人可执行可读chmod(&quot;file.php&quot;, 0635);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础(二)]]></title>
      <url>%2F2017%2F02%2F21%2FPHP%E5%9F%BA%E7%A1%80(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[PHP的字符串首先来区别一下下面两种字符串:echo “hello”.”world”;echo “hello”,”world”;注意:这里第一条是一个字符串，第二条是两个字符串 字符串的查找这里用strpos();命令用法：strpos(要操作的字符串，要查找的字符)返回查找字符的位置$str = “hello world”;echo strpos($str, “w”); // 返回的是第一次查找的位置 输出6echo stripos($str, “W”); // stripos是不区分大小写的查找 也是输出6字符串的替换这里用str_replace();命令替换字符串的匹配内容用法：str_replace(匹配内容,替换内容,字符串)$str = str_replace(“l”, ““, $str); // 能将全部查找的到的都进行替换echo $str; // 输出he**o word$str = str_ireplace(“L”, ““, $str); // 同样不区分大小写echo $str; // 输出he**o word字符串的截取这里有substr();命令截取用法：substr(字符串,截取的起始长度(可以为负数),截取的长度)$str = “hello world”;$str = substr($str, 3); // $str为lo world$str = substr($str, 3, 7); // $str为lo worl$str = substr($str, -4, 3); // $str为orl字符串的截取2PHP也有第二种截取命令strstr();strstr(字符串,截取的字符)$str = “hello world”;$str = strstr($str, “ll”);$str = stristr($str, “LL”); // 不区分大小写字符串的去除空格这里有ltrim();rtrim();trim();三种方法。分别是去除左边空格，去除右边空格，和去除两边空格$str = “ hello “;$str = ltrim($str); // 去除左边的空格$str = rtrim($str); // 去除有边的空格$str = trim($str); // 去除所有空格获取字符串长度用strlen();来获取$str = “wwwwwwwww”;echo strlen($str); // 这里输出为8字符串的大小写转换及反转1.转换成小写$str = “ABCD”;echo strtolower($str); // 输出结果为abcd2.转换成大写$str = “abcd”;echo strtoupper($str); // 输出结果为ABCD3.反转$str = “abcd”;echo strrev($str); // 输出结果为ABCD去除字符串中的标签strip_tags();字符串的换行符nl2br();$str = “AB\nCD”;echo nl2br($str); // 输出结果为AB //CDPHP的数组数组的创建PHP的数据创建有三种方式：1.array();创建$fruit = array(“apple”, “orange”, “banana”);$fruit[] = “pear”; // 在数组最后添加$language = array(“en” =&gt; “English”, “ch” =&gt; “Chinese”);//“en”为键，”English”为值$language[“fr”] = “French”; // 在数组最后添加2.直接赋值$fruit[] = “orange”;$fruit[] = “banana”;3.rang();创建$num = range(0, 5); // 从0至5按顺序填充到数组中获取数组的长度使用count();获取$num = range(0, 5);echo “该数组长度”.count($letter); // 输出结果为6这里说一下我们一般输出数组用的是print_r();这个方法判断是否为数组可以使用is_array();$a = array(“a”);echo is_array($letter);判断数组是否存在某个值用in_array();$letter = range(“a”, “A”);if (in_array(“B”, $letter)) echo “数组中有b”;else echo “数组中没有b”;遍历数组这里博主推荐使用foreach来遍历较为方便用法：foreach ($数组 as $数组的键 =&gt; $数组的值) {…..}foreach ($letter as $key =&gt; $value) { echo $key.”的值是”.$value;}foreach ($letter as $value) { echo “值为”.$value;}数组的排序方式1.sort rsortsort, rsort是给索引数组的排序$fruit = array(“orange”, “banana”, “apple”);sort($fruit); // 升序rsort($fruit); // 降序2.ksort krsortksort, krsort是依据关联数组的键排序$fruit = array(“b” =&gt; “orange”, “a” =&gt; “banana”, “c” =&gt; “apple”);ksort($fruit); // 升序krsort($fruit); // 降序3.asort arsortasort, arsort是根据关联数组的值排序$fruit = array(“b” =&gt; “orange”, “a” =&gt; “banana”, “c” =&gt; “apple”);asort($fruit); // 升序arsort($fruit); // 降序二维数组$people = array( array(“name” =&gt; “zhangsan” , “sex” =&gt; “man”), array(“name” =&gt; “lisi” , “sex” =&gt; “female”), array(“name” =&gt; “wangwu” , “sex” =&gt; “man”));二维数组的遍历方法foreach ($people as $key =&gt; $newArr) { var_dump($newArr); foreach ($newArr as $key =&gt; $value) { echo $key.”的值是”.$value; }}PHP数组和字符串之间的转换数组转换字符串用implode();转换用法：implode(分隔符，要操作的数组)$arr = array(1, 2, 3, 4 ,5);$str = implode(“”, $arr);echo $str; // 输出为12345字符串转换数组用explode();转换用法：explode(分隔符，要操作的字符串)$str = “a,b,c,d,e”;$arr = explode(“,”, $str);print_r($arr); // 输出Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; e )PHP对文件的操作打开文件$fh = fopen(“test.txt”, “a”);a表示操作权限，会在后面讲到，要想对文件进行操作就必须要先打开文件读取文件1.filesize获取文件大小filesize，返回字符串$str = fread($fh, filesize(“test.txt”)); // 可以读取文件的内容2.fgetsfgets，返回字符串，只返回一行，再次运行返回就从下一行开始while ($str = fgets($fh)) { echo $str.”&lt;hr/&gt;“;}3.filefile，返回数组$arr = file(“test.txt”);4.file_get_contentsfile_get_contents获取文件内容，并把内容当成字符串返回出来，也可以用绝对路径打开一个网页$str = file_get_contents(“test.txt”);$str = file_get_contents(“https://www.baidu.com“);文件写入fwrite($fh, “我是写入的内容”);关闭文件fclose($fh);新建文件$fh = fopen(“test2.txt”, “a”);fwrite($fh, “我是新建的”);fclose($fh);新建文件2file_put_contents(“test2.txt”, “我是put进去的”);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础(一)]]></title>
      <url>%2F2017%2F02%2F20%2FPHP%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[初识PHPPHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。我们有时可以看到以.php作为后缀名的文件，这就是PHP文件，它可以包含文本、HTML、JavaScript代码和PHP代码，且PHP代码在服务器上执行，结果以纯HTML形式返回给浏览器。PHP标记&lt;?php /*所有的php代码就写在这*/ ?&gt; PHP的基本语法1.单行注释包括&nbsp;&nbsp;’//‘,&nbsp;&nbsp;’#’,&nbsp;&nbsp;多行注释’/…/‘2.php必须在指令末尾加上分号3.对大小写敏感PHP的变量变量的规则PHP的变量名由字母、数字、下划线组成变量名也是区分大小写的变量的声明PHP的变量声明符号是$例如:$a = 10;$b = “hello world”;变量的传值$a = 10;$b = $a;echo $a, $b; // $a = 10, $b = 10$b = 20;echo $a, $b; // $a = 10, $b = 20变量的传址$a = 10;$b = &amp;$a;echo $a, $b; // $a = 10, $b = 10$b = 20;echo $a, $b; // $a = 20, $b = 20变量的变量$a = “hello”;$$a = “world”;echo $hello; // 输出world$a = “hello”;$hello = “world”;echo $$a; // 输出也是worldPHP的超全局变量PHP的超全局变量有很多，这里举例说几个:$_SERVER:包含了服务器与执行环境的一些信息var_dump:输出任何类型的数据，以及数据类型和数据长度$_GET:获得通过get方式传送的数据$_POST:获得post方式传输的数据$_REQUEST:既能获得get方式，又能获得post方式$GLOBALS:引用全局作用域中可用的全部变量这里介绍下，$GLOBALS的简单用法$a = 10;$b = 15;echo $GLOBALS[“a”] + $GLOBALS[“b”]; // 输出为25想了解更多的有关PHP超全局变量的可以查询PHP的超全局变量PHP的常量常量的介绍常量是一个一经定义就无法改变的量。常量的定义方法是用define();常量对大小写敏感常量输出时不加$常量的值只能是数值(整形，浮点型)，字符串，以及布尔。// 常量的定义方法:define(常量名, 常量值)define(“PI”, 3.1415926);echo PI; // 输出3.1415926内置常量PHP的内置常量也有很多，这里举例说明几个：PHP_OS:获得当前运行的操作系统PHP_VERSION:显示PHP的版本想了解更多的有关PHP内置常量的可以查询PHP的内置常量魔术常量PHP的魔术常量有很多，这里举例说明几个：__LINE__:显示当前的行数魔术常量会根据位置不同返回不同的值__FILE__:显示文件名__DIR__:显示目录想了解更多的有关PHP魔术常量的可以查询PHP的魔术常量PHP的变量类型PHP变量的类型四种标量数据类型：字符串、布尔、整型、浮点型。两种复杂数据类型：数组和对象。两种特殊数据类型：资源和null。1.整型$num = 10;$num = -10;$num = 075; // 八进制的$num = 0xA1; // 十六进制的$num = 7e10; // 科学计数法2.浮点型(小数)$num = 3.3e-2; // 输出0.03313.布尔型echo true; // 1echo false; // 什么也不输出4.字符串定义字符串有三种包括单引号，双引号，定界符注意：单引号不能解析变量以及字符，而双引号可以$a = “zhangsan”;$str = “hel\nlo $a {$a}bc”;echo $str; // 输出结果为hel lo zhangsan zhangsanbc5.数组$arr = array(1, 3, 4, 5);var_dump($arr); // 注意数组输出用var_dump6.对象对象类型的可以通过类的实例化或者强制转换创建7.资源资源类型的可以通过读取文件之类的操作获得的如:$fh = open(“text.txt”,”w”);8.Null直接赋值为null; 未定义的为空的类型转换(隐式类型转换)$num = 10;$str = “10dsvgnsdnhfv”;echo $num + $str; // “+”只能进行数值运算 输出结果为201.如果想获取这个变量的类型可以使用gettype($变量名)例如:$num = 10;echo gettype($num); // 输出类型是integer2.如果想判断这个变量是否是字符串可以使用is_string($变量名)例如: $str = “hello”;echo gettype($str); // 输出类型是1定界符之heredoc标识符顶格写，标识符独占一行示例: $name = “张三”; $str = &lt;&lt;&lt;EOF 你好，{$name}!EOF; // 注意这里”EOF”要顶格写！ echo $str; // 输出结果为你好，张三！PHP的运算符基本的语法还是与JavaScript大致相同，不过每个变量之前都需要加上”$”的符号。这里就说明几个特殊的:PHP字符串的拼接字符串之间进行拼接用”.”例如:$a = “hello”;$b = “你好”;$sum = $a.$b;echo $sum; // 输出hello你好$a = “hello”;$a.=”world”;echo $a; // $a = $a.”world”; 输出结果为helloworld自增$i = 0;$i++; // 变量使用时，要带上$符PHP的函数自定义函数function show(){ echo “自定义函数”;}show();传参函数实例一:function add($a, $b){ echo $a + $b;}实例二:function defaults($h, $hobby = “打代码”){ echo “我的兴趣是{$play}，一写就是{$h}小时”;}defaults(10, “写代码”);// 注意这里要传参传默认值的参数需要写在最后一位递归函数$a = 10;$b = 15; // 注意在PHP中$a和$b这里是全局变量，在函数内部访问不到function digui(){ // 要调用全局变量$a和$b这里推荐两个方法 echo s[“a”]+$GLOBALS[“b”]; global $a, $b; echo $a + $b;}digui();函数内部的静态变量function fn(){ static $i = 0; // 静态变量 和闭包类似的功能，垃圾不销毁机制 echo $i;$i++;}fn(); // 输出0fn(); // 输出1fn(); // 输出2PHP的表单这里就用实例说明:在一个html文件中写入&lt;body&gt; &lt;a href=&quot;test.php?pid=10&quot;&gt;链接到某某页&lt;/a&gt; &lt;form action=&quot;test.php&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot; /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;在test.php文件中写入&lt;?php var_dump($_GET); $pid = $_GET[“pid”]; echo $pid;?&gt;这样就可以获取到在html页面中的input框内填入的数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的一些基本知识]]></title>
      <url>%2F2017%2F02%2F20%2FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[JavaScript中的变量 一、变量的规则 1.首字母必须是英文字母或者下划线2.由英文字母、数字、下划线和$组成3.不能与JavaScript关键词和保留字重名4.最好以驼峰命名法，第一个单词首字母小写，其它单词首字母大写二、变量的声明方法var 变量名例如：var a = 10;&nbsp;&nbsp;(变量名a是不分类型的，但是a里面存储的值是分类型的)如果想获取变量a的值的类型可以是用”typeof”。如：console.log(typeof a) 打印一下a的值的种类三、变量的转换方式1.显示转换1.String(); 可以把括号内的值转化为字符串类型2.Number(); 可以把括号内的值转化为数值类型，如果是字符串，字符串的内容必须是整数或者小数，不能有其他字符3.parseInt(); 转数值类型，可以理解为是取整操作，可以有其他字符，转化的时候其它字符以后的内容不转化。2.隐示转换隐士转换是什么意思呢?就是计算机自己帮我们做的类型转换。比如： 1 + “2” 会出现什么结果呢?计算机会认为+是一个取正操作符，运算符重载。把1转化成”1”然后和2进行拼接。所以结果是12四、变量的作用域不管全局变量还是局部变量，尽量都不要重名。1.全局变量 在函数外部声明的可以称之为是全局变量，在任何地方都可以使用。2.局部变量 局部变量值，在函数内声明的变量，只能在函数内部使用。博主自己整理的一些JavaScript中变量的知识 五、变量的数据类型1.基本数据类型numberstringboolundefinednull2.复杂数据类型object JavaScript中的运算符 一、大小关系基本的&nbsp;&nbsp;”&gt;,&lt;,=,&gt;=,&lt;=”&nbsp;&nbsp;博主就不在此多说了，相信各位对代码感兴趣的同学都懂~在js中”==”则是比较两个运算数的返回值是否相等，”!=”则是返回值不相等而”===”则是比较两个运算数的返回值和数据的类型是否都相等。“!==”则是返回值和数据的类型都不相等。二、算数运算符同样正常的&nbsp;&nbsp;”+ - * / %”&nbsp;&nbsp;也不用多说了。这里要提两点： 1.”+”号不仅有求和的运算，还能够进行字符串拼接，如之前说的可以帮我们进行隐示转换。2.”-“号也不仅只有减法运算，还能够对操作的数值进行取反作用。 三、自增和自减i++/i--加或减在变量之前，就先计算出变量的值，再进行其他操作。加或减在变量之后，就先进行下面操作，再对变量进行求值。 四、逻辑运算符1.逻辑与(&amp;&amp;)当条件有2个的时候会用到逻辑运算符，如果两个条件都为true则返回true。1.短路与逻辑与需要多个条件都为真的时候整个表达式才是真，所以当前面的条件为假的时候，就不会去执行后面的判断条件。3.逻辑或(||)用逻辑或连接的两个bool值，只要有一个为真，整个表达式就为真，两个bool都为假的时候，整个表达式为假。4.短路或需要多个条件有一个为真的时候整个表达式就是真，所以当前面的条件为真的时候，就不会去执行后面的判断条件。5.逻辑非(!)如果条件返回值是true则返回false，如果是false则返回true。 五、三元表达式格式为：条件 ? 结果1 : 结果2例如：5 &gt; 4 ? true : false因为5大于4这个结果是真的所以显示为true。博主自己整理的一些JavaScript中变量运算符的知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[个人收集的前端相关的网站]]></title>
      <url>%2F2017%2F02%2F18%2F%E4%B8%AA%E4%BA%BA%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[学习类w3schoolw3cmark前端笔记快课网知识库 - CSDN无线Web开发经验谈极客标签往期回顾码农周刊慕课网Div.IOw3cplus_引领web前沿，打造前端精品教程JavaScript | MDNcanvas动画包教不包会网易云课堂绿叶学习网前端收费视频课程分享 | ByZhkc3PHP: PHP 手册 - Manual介绍 - vue.js微信小程序接入指南csssecrets jQuery类jQuery之家jQuery插件库jQuery API 3.1 中文文档 社区论坛博客类Lymoo’s blog微信小程序联盟CSDN.NET博客园廖雪峰掘金阮一峰张鑫旭十年踪迹王福朋彬Go前端人的俱乐部WEB前端开发囧克斯前端开发博客大漠穷秋Taobao FED腾讯小楼昨夜又秋风 - 知乎专栏知乎 前端综合类广场 - 看云前端导航黑客新闻InfoQ中文站Aotu.io「凹凸实验室」Top Pens of 2013 on CodePenHTML5资源教程html5前端开发技术分享网前端网（QDFuns）CSS Gradients with background-blend-modeCSS魔法 - 弧形排列的可折叠二级导航编程之家踏得网晚晴幽草轩 前端工具类Swiper中文网图片压缩日期控件与时间插件mac svn客户端墨刀JavaScript正则在线测试工具CSS3的测试你的浏览器支持 ES6 吗？ - ES-CheckerASCII码对照表史蒂芬周的博客Avocode - PSD Node类七天学会NodeJSCNode技术社区 面试题类前端开发面试题小集前端工作面试问题小集我是如何同时拿到阿里和腾讯offer的 - Web开发手记 - SegmentFault前端面试经典题目合集_牛客网web前端面试题目-朝圣言BAT及各大互联网公司2014前端笔试面试题–JavaScript篇 - ChokCoco前端面试题 - kongjiea笔记 - 博客频道]]></content>
    </entry>

    
  
  
</search>
